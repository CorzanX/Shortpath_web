"use strict";(self["webpackChunkcorzanx"]=self["webpackChunkcorzanx"]||[]).push([[768],{31768:function(e,t,s){s.r(t),s.d(t,{default:function(){return C}});var r=function(){var e=this,t=e._self._c;return t("div",[t("h1",[e._v("Comparison of Shortest Path Algorithm")]),t("h2",[e._v("Scope of Application")]),t("br"),e._v(" ·Dijkstra's algorithm and SPFA algorithm are suitable for the single-source shortest path problem, that is, to calculate the shortest path from one vertex to other vertices in the graph."),t("br"),e._v(" ·The Floyd-Warshall algorithm is suitable for the multi-source shortest path problem, that is, to calculate the shortest path between any two vertices in the graph."),t("br"),e._v(" ·The Bellman-Ford algorithm is suitable for the shortest path problem with negative weight edges, that is, to deal with graphs containing negative weight edges."),t("br"),t("br"),t("h2",[e._v("Time Complexity")]),t("time_cpx"),t("br"),t("h2",[e._v("Analysis")]),e._v(" (1) Find the shortest path with a single source and no negative weight. The timeliness is good, and the time complexity is O(V*V+E). If the source is reachable, O(V*lgV+E*lgV)=>O(E*lgV). In the case of a sparse graph, E=V*V/lgV at this time, so the time complexity of the algorithm can be O(V^2). "),t("br"),t("br"),e._v(" (2) Unlike the Dijkstra algorithm, in the Bellman-Ford algorithm, the weight of an edge can be negative. Imagine that we can find a cycle from the graph (that is, starting from v, returning to v after passing through several points) and the sum of the weights of all edges in this cycle is negative. Then through this loop, the shortest path between any two points in the loop can be infinitely small. If this negative loop is not dealt with, the program will run forever. The Bellman-Ford algorithm has the ability to distinguish such negative loops. "),t("br"),t("br"),e._v(" (3) The SPFA algorithm is Bellman-Ford's queue optimization, which has relatively good timeliness and a time complexity of O(kE). (k<<V). "),t("br"),t("br"),t("h2",[e._v("Verification of efficiency")]),e._v(" To illustrate the efficiency of each algorithm in different cases, we present multiple graphs."),t("br"),e._v(" And the running time of the corresponding algorithm function is given."),t("br"),t("h3",[e._v("Graph of cities")]),t("random"),t("h3",[e._v("A dense graph")]),t("dense"),t("h3",[e._v("A sparse graph")]),t("sparse"),t("h3",[e._v("A graph with negative numbers")]),t("negative"),t("h3",[e._v("Conclusion")]),e._v(" So,we can find that in dense graph and sparse graph, the performance of these four shortest path algorithms may be somewhat different."),t("br"),t("br"),e._v("For Dense Graph, it means that the number of vertices (V) and edges (E) are relatively large, and the number of edges is close to the square of V. On dense graphs, Floyd-Warshall may perform well because its time complexity is O(V^3), independent of the number of edges, and is suitable for dealing with the shortest path between any two vertices. In contrast, the time complexity of Dijkstra and Bellman-Ford algorithms is related to the number of edges, so they may behave slowly on dense graphs."),t("br"),t("br"),e._v("For Sparse Graph, the number of vertices (V) and edges (E) is relatively small, and the number of edges is far less than the square of V. On sparse graphs, Dijkstra algorithm and Bellman-Ford algorithm may perform better. Dijkstra algorithm uses priority queue to select vertices, which is suitable for single source shortest path problem. However, the time complexity of Bellman-Ford algorithm is related to the number of edges, but for sparse graphs with small number of edges, it can still efficiently calculate the shortest path."),t("br"),t("br"),e._v("Specially,The performance of SPFA algorithm may vary between dense and sparse graphs, because its worst-case time complexity is O(VE). SPFA may be faster than Dijkstra in some specific sparse graph cases, but worst-case performance needs to be taken care of."),t("br"),t("br"),e._v("It should be noted that the SPFA algorithm is usually faster than the average case of Dijkstra algorithm when dealing with sparse graphs (relatively few edges), because it uses the queue for vertex selection and can avoid unnecessary relaxation operations. However, in the worst case, the SPFA algorithm has a high time complexity and may not be as good as Dijkstra's algorithm or other algorithms that are better suited to dealing with negative edge weights, such as Bellman-Ford."),t("br"),t("br"),e._v("Therefore, when selecting the shortest path algorithm, the characteristics of the graph (dense or sparse), the problem requirements and the time complexity of the algorithm should be considered to find the most appropriate algorithm. ")],1)},a=[],i=function(){var e=this;e._self._c;return e._m(0)},n=[function(){var e=this,t=e._self._c;return t("div",[t("table",[t("tr",{staticClass:"blue-row"},[t("td",[e._v("Dijkstra")]),t("td",[e._v("Floyd")]),t("td",[e._v("SPFA")]),t("td",[e._v("Bellman-Ford")])]),t("tr",[t("td",[e._v("O((V + E)log V)")]),t("td",[e._v("O(V^3)")]),t("td",[e._v("O(E)~O(VE)")]),t("td",[e._v("O(VE)")])])]),e._v(" PS:In this table ,V for vertex and E for edge"),t("br")])}],h={components:{}},o=h,l=s(1001),d=(0,l.Z)(o,i,n,!1,null,"e3f68fb0",null),c=d.exports,g=function(){var e=this,t=e._self._c;return t("div",[e.isLoading?e._e():t("div",[t("undirected_graph",{attrs:{parentHeight:300,parentWidth:300,links:e.links,nodes:e.nodes}})],1),t("p",{staticStyle:{"white-space":"pre-wrap"}},[e._v(e._s(e.str))])])},p=[],m=s(20306),u=s(58488),f={components:{undirected_graph:u.Z},data(){return{nodes:[],links:[],str:"",isLoading:!0}},created(){this.fetchgraph(),this.fetchstr()},methods:{fetchgraph(){m.Z.get("/cmp_dense").then((e=>{const t=e.data;this.nodes=Object.values(t.nodes).map((e=>({id:e.id,name:e.name}))),this.links=Object.values(t.links).map((e=>({source:e.source,target:e.target,weight:e.weight}))),this.isLoading=!1})).catch((e=>{console.error(e)}))},fetchstr(){m.Z.get("/cmp_dense_times").then((e=>{this.str=e.data})).catch((e=>{console.error(e)}))}}},v=f,b=(0,l.Z)(v,g,p,!1,null,null,null),_=b.exports,y=function(){var e=this,t=e._self._c;return t("div",[e.isLoading?e._e():t("div",[t("undirected_graph",{attrs:{parentHeight:300,parentWidth:700,links:e.links,nodes:e.nodes}})],1),t("p",{staticStyle:{"white-space":"pre-wrap"}},[e._v(e._s(e.str))])])},w=[],k={components:{undirected_graph:u.Z},data(){return{nodes:[],links:[],str:"",isLoading:!0}},created(){this.fetchgraph(),this.fetchstr()},methods:{fetchgraph(){m.Z.get("/cmp_random").then((e=>{const t=e.data;this.nodes=Object.values(t.nodes).map((e=>({id:e.id,name:e.name}))),this.links=Object.values(t.links).map((e=>({source:e.source,target:e.target,weight:e.weight}))),this.isLoading=!1})).catch((e=>{console.error(e)}))},fetchstr(){m.Z.get("/cmp_random_times").then((e=>{this.str=e.data})).catch((e=>{console.error(e)}))}}},x=k,V=(0,l.Z)(x,y,w,!1,null,null,null),F=V.exports,O=function(){var e=this,t=e._self._c;return t("div",[e.isLoading?e._e():t("div",[t("undirected_graph",{attrs:{parentHeight:300,parentWidth:700,links:e.links,nodes:e.nodes}})],1),t("p",{staticStyle:{"white-space":"pre-wrap"}},[e._v(e._s(e.str))])])},A=[],Z={components:{undirected_graph:u.Z},data(){return{nodes:[],links:[],str:"",isLoading:!0}},created(){this.fetchgraph(),this.fetchstr()},methods:{fetchgraph(){m.Z.get("/cmp_sparse").then((e=>{const t=e.data;this.nodes=Object.values(t.nodes).map((e=>({id:e.id,name:e.name}))),this.links=Object.values(t.links).map((e=>({source:e.source,target:e.target,weight:e.weight}))),this.isLoading=!1})).catch((e=>{console.error(e)}))},fetchstr(){m.Z.get("/cmp_sparse_times").then((e=>{this.str=e.data})).catch((e=>{console.error(e)}))}}},j=Z,S=(0,l.Z)(j,O,A,!1,null,null,null),B=S.exports,E=function(){var e=this,t=e._self._c;return t("div",[e.isLoading?e._e():t("div",[t("undirected_graph",{attrs:{parentHeight:300,parentWidth:300,links:e.links,nodes:e.nodes}})],1),t("p",{staticStyle:{"white-space":"pre-wrap"}},[e._v(e._s(e.str))])])},L=[],T={components:{undirected_graph:u.Z},data(){return{nodes:[],links:[],str:"",isLoading:!0}},created(){this.fetchgraph(),this.fetchstr()},methods:{fetchgraph(){m.Z.get("/cmp_negative").then((e=>{const t=e.data;this.nodes=Object.values(t.nodes).map((e=>({id:e.id,name:e.name}))),this.links=Object.values(t.links).map((e=>({source:e.source,target:e.target,weight:e.weight}))),this.isLoading=!1})).catch((e=>{console.error(e)}))},fetchstr(){m.Z.get("/cmp_negative_times").then((e=>{this.str=e.data})).catch((e=>{console.error(e)}))}}},q=T,D=(0,l.Z)(q,E,L,!1,null,null,null),H=D.exports,P={components:{time_cpx:c,dense:_,random:F,sparse:B,negative:H}},W=P,I=(0,l.Z)(W,r,a,!1,null,"f54896a0",null),C=I.exports},58488:function(e,t,s){s.d(t,{Z:function(){return d}});var r=function(){var e=this,t=e._self._c;return t("div",[t("svg",{ref:"svg",attrs:{width:e.parentWidth,height:e.parentHeight}})])},a=[],i=s(4592),n={name:"undirected_graph",props:{nodes:{type:Array,required:!0},links:{type:Array,required:!0},parentWidth:Number,parentHeight:Number},mounted(){this.initGraph()},methods:{initGraph(){this.simulation=i.A4v(this.nodes).force("link",i.Fsl(this.links).id((e=>e.id))).force("charge",i.q5i().strength(-500)).force("center",i.wqt(this.parentWidth/2,this.parentHeight/2));const e=i.Ys(this.$refs.svg);this.link=e.selectAll("line").data(this.links).enter().append("line").attr("stroke","#999"),this.node=e.selectAll("circle").data(this.nodes).enter().append("circle").attr("r",20).attr("fill","lightblue").call(i.ohM().on("start",this.dragstart).on("drag",this.dragged).on("end",this.dragend)),this.label=e.selectAll(null).data(this.nodes).enter().append("text").attr("text-anchor","middle").attr("font-size","12px").attr("dy","-0em").text((e=>e.name)),this.weight_label=e.selectAll(null).data(this.links).enter().append("text").attr("text-anchor","middle").attr("font-size","12px").attr("dy","-0em").text((e=>e.weight)),this.simulation.nodes(this.nodes).on("tick",this.ticked),this.simulation.force("link").links(this.links)},ticked(){this.link.attr("x1",(e=>e.source.x)).attr("y1",(e=>e.source.y)).attr("x2",(e=>e.target.x)).attr("y2",(e=>e.target.y)),this.node.attr("cx",(e=>e.x)).attr("cy",(e=>e.y)),this.label.attr("x",(e=>e.x)).attr("y",(e=>e.y)),this.weight_label.attr("x",(e=>(e.source.x+e.target.x)/2)).attr("y",(e=>(e.source.y+e.target.y)/2))},dragstart(e){i.Ba6.active||this.simulation.alphaTarget(.3).restart(),e.fx=e.x,e.fy=e.y},dragged(e){e.x=i.Ba6.x,e.y=i.Ba6.y},dragend(e){i.Ba6.active||this.simulation.alphaTarget(0),e.fx=null,e.fy=null}}},h=n,o=s(1001),l=(0,o.Z)(h,r,a,!1,null,null,null),d=l.exports}}]);
//# sourceMappingURL=768.150e9f1c.js.map