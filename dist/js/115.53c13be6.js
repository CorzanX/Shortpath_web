"use strict";(self["webpackChunkcorzanx"]=self["webpackChunkcorzanx"]||[]).push([[115],{46115:function(e,t,n){n.r(t),n.d(t,{default:function(){return B}});var i=function(){var e=this,t=e._self._c;return t("div",[t("h1",[e._v("Bellman-Ford")]),t("p",[e._v("The American applied mathematician Richard Bellman (Richard. Behrman, the author of dynamic programming, published the algorithm in 1958. Lester Ford also published this algorithm in 1956. So this algorithm is called Bellman-Ford. In fact, EdwardF. Moore published the same algorithm in 1957, so this algorithm is also called Bellman-Ford-Moore algorithm.")]),t("h2",[e._v("The realization of Bellman-Ford")]),e._v(" Like Dijkstra's algorithm, Bellman–Ford proceeds by relaxation, in which approximations to the correct distance are replaced by better ones until they eventually reach the solution. In both algorithms, the approximate distance to each vertex is always an overestimate of the true distance, and is replaced by the minimum of its old value and the length of a newly found path. However, Dijkstra's algorithm uses a priority queue to greedily select the closest vertex that has not yet been processed, and performs this relaxation process on all of its outgoing edges; by contrast, the Bellman–Ford algorithm simply relaxes all the edges, and does this |V|-1 times, where |V| is the number of vertices in the graph. In each of these repetitions, the number of vertices with correctly calculated distances grows, from which it follows that eventually all vertices will have their correct distances. This method allows the Bellman–Ford algorithm to be applied to a wider class of inputs than Dijkstra. The intermediate answers depend on the order of edges relaxed, but the final answer remains the same. "),t("br"),e._v(" There is a exmaple"),t("br"),t("img",{attrs:{src:n(63092),width:"60%"}}),t("br"),e._v(" In this example graph, assuming that A is the source and edges are processed in the worst order, from right to left, it requires the full |V|−1 or 4 iterations for the distance estimates to converge. Conversely, if the edges are processed in the best order, from left to right, the algorithm converges in a single iteration."),t("br"),t("img",{attrs:{src:n(39),width:"60%"}}),t("br"),t("h2",[e._v("Core Code")]),t("h3",[e._v("cpp")]),t("bf_cpp"),t("h3",[e._v("java")]),t("bf_java"),t("h3",[e._v("python")]),t("bf_py")],1)},s=[],r=function(){var e=this,t=e._self._c;return t("div",[t("pre",{directives:[{name:"highlightA",rawName:"v-highlightA"}]},[e._v("        "),t("code",{staticClass:"cpp"},[e._v("\n            "+e._s(e.code)+"\n        ")]),e._v("\n    ")])])},a=[],o={data(){return{code:'\nstruct Edge {\n    int source, destination, weight;\n};\n\nvoid bellmanFord(std::vector<Edge>& edges, int numVertices, int source) {\n    std::vector<int> distance(numVertices, std::numeric_limits<int>::max());\n    distance[source] = 0;\n\n    for (int i = 1; i <= numVertices - 1; ++i) {\n        for (const auto& edge : edges) {\n            int u = edge.source;\n            int v = edge.destination;\n            int weight = edge.weight;\n\n            if (distance[u] != std::numeric_limits<int>::max() && distance[u] + weight < distance[v]) {\n                distance[v] = distance[u] + weight;\n            }\n        }\n    }\n\n    // Detect negative weight loops\n    for (const auto& edge : edges) {\n        int u = edge.source;\n        int v = edge.destination;\n        int weight = edge.weight;\n\n        if (distance[u] != std::numeric_limits<int>::max() && distance[u] + weight < distance[v]) {\n            std::cout << "There are negative weight loops in the graph!" << std::endl;\n            return;\n        }\n    }\n\n    // output shortest path\n    std::cout << "Vertice\tshortest path" << std::endl;\n    for (int i = 0; i < numVertices; ++i) {\n        std::cout << i << "\t" << distance[i] << std::endl;\n    }\n}\n            '}}},d=o,h=n(1001),c=(0,h.Z)(d,r,a,!1,null,"20ea4150",null),l=c.exports,g=function(){var e=this,t=e._self._c;return t("div",[t("pre",{directives:[{name:"highlightA",rawName:"v-highlightA"}]},[e._v("        "),t("code",{staticClass:"java"},[e._v("\n            "+e._s(e.code)+"\n        ")]),e._v("\n    ")])])},u=[],m={data(){return{code:'\nclass Edge {\n    int source, destination, weight;\n\n    public Edge(int source, int destination, int weight) {\n        this.source = source;\n        this.destination = destination;\n        this.weight = weight;\n    }\n}\n\npublic class BellmanFord {\n    public static void bellmanFord(Edge[] edges, int numVertices, int source) {\n        int[] distance = new int[numVertices];\n        Arrays.fill(distance, Integer.MAX_VALUE);\n        distance[source] = 0;\n\n        for (int i = 1; i <= numVertices - 1; ++i) {\n            for (Edge edge : edges) {\n                int u = edge.source;\n                int v = edge.destination;\n                int weight = edge.weight;\n\n                if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {\n                    distance[v] = distance[u] + weight;\n                }\n            }\n        }\n\n        // Detect negative weight loops\n        for (Edge edge : edges) {\n            int u = edge.source;\n            int v = edge.destination;\n            int weight = edge.weight;\n\n            if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {\n                System.out.println("There are negative weight loops in the graph!");\n                return;\n            }\n        }\n\n        // output shortest path\n        System.out.println("Vertice\tshortest path");\n        for (int i = 0; i < numVertices; ++i) {\n            System.out.println(i + "\t" + distance[i]);\n        }\n    }\n            '}}},p=m,v=(0,h.Z)(p,g,u,!1,null,"40968b79",null),f=v.exports,w=function(){var e=this,t=e._self._c;return t("div",[t("pre",{directives:[{name:"highlightA",rawName:"v-highlightA"}]},[e._v("        "),t("code",{staticClass:"python"},[e._v("\n            "+e._s(e.code)+"\n        ")]),e._v("\n    ")])])},_=[],b={data(){return{code:"\ndef bellman_ford(edges, num_vertices, source):\n    distance = [float('inf')] * num_vertices\n    distance[source] = 0\n\n    for _ in range(num_vertices - 1):\n        for edge in edges:\n            u, v, weight = edge\n\n            if distance[u] != float('inf') and distance[u] + weight < distance[v]:\n                distance[v] = distance[u] + weight\n\n    # Detect negative weight loops\n    for edge in edges:\n        u, v, weight = edge\n\n        if distance[u] != float('inf') and distance[u] + weight < distance[v]:\n            print(\"There are negative weight loops in the graph!\")\n            return\n\n    # output shortest path\n    print(\"Vertice\tshortest path\")\n    for i in range(num_vertices):\n        print(i, \"\t\", distance[i])\n            "}}},y=b,x=(0,h.Z)(y,w,_,!1,null,"096560fa",null),V=x.exports,A={components:{bf_cpp:l,bf_java:f,bf_py:V}},F=A,E=(0,h.Z)(F,i,s,!1,null,"38fa8f05",null),B=E.exports},39:function(e,t,n){e.exports=n.p+"img/bm.4998a38f.png"},63092:function(e,t,n){e.exports=n.p+"img/bm_example.f718003e.gif"}}]);
//# sourceMappingURL=115.53c13be6.js.map