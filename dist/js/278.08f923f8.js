"use strict";(self["webpackChunkcorzanx"]=self["webpackChunkcorzanx"]||[]).push([[278],{40278:function(t,e,s){s.r(e),s.d(e,{default:function(){return It}});var n=function(){var t=this,e=t._self._c;return e("div",[e("h1",[t._v("Dijkstra")]),e("p",[t._v("Dijkstra's algorithm is a graph traversal algorithm that is used to find the shortest path between a starting node and all other nodes in a weighted graph. It was developed by Dutch computer scientist Edsger W. Dijkstra in 1956.")]),e("p",[t._v("Dijkstra algorithm is used to find the shortest path from one vertex to all other vertices in the graph. It is suitable for both unweighted graphs and directed weighted graphs.")]),e("p",[t._v("Note that when using Dijkstra algorithm to find the shortest path, the weights of all edges in the graph must be guaranteed to be non-negative, otherwise the search process is easy to make mistakes.")]),e("h2",[t._v("The realization of Dijkstra algorithm")]),e("img",{attrs:{src:s(36231),width:"600",height:"auto"}}),e("br"),t._v(" First of all, we can set up two sets, A and B. "),e("p",{staticStyle:{color:"red"}},[t._v("A is used to store the points where the shortest path has been calculated, and B is used to store the points where the shortest path has not been calculated.")]),t._v(" So let's do this at any point on the graph, and let's say we choose source at 0. So the distance from all the initial points to 0 we're going to assume is ∞, which means unreachable. The distance from source point 0 to itself is 0, and the initialization is as follows: Then set A is: {0}, set B is: {1,2,3,4,5,6} "),t._m(0),e("step1"),e("step2"),e("step3"),e("step4"),e("step5"),e("step6"),e("step7"),e("step8"),e("step9"),e("step10"),e("step11"),e("step12"),e("br"),e("br"),e("h2",[t._v("NOTE")]),e("h3",[t._v("1. Graphs with negative weighted edges cannot be processed (the optimal solution may not be obtained, so it is considered that negative weighted graphs cannot be processed), but only non-negative weighted graphs can be processed.")]),e("p",[t._v("Why? In this graph for example, according to Dijkstra's idea, first the 0 point is added to the set, then the 1 point is added to the set, then the 3 point is added to the set, and then the 2 is added to the set, then the 0-> 2 has been updated to 99-300, but it is no longer available. 3 (the original value was 2).")]),e("img",{attrs:{src:s(49434),width:"60%"}}),e("h3",[t._v("2. Only the single-source shortest path problem can be solved")]),e("br"),e("br"),e("h2",[t._v("Core Code")]),e("h3",[t._v("cpp")]),e("dij_cpp"),e("h3",[t._v("java")]),e("dij_java"),e("h3",[t._v("python")]),e("dij_python")],1)},i=[function(){var t=this,e=t._self._c;return e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",[e("td",[t._v("1")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("2")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("3")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("4")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])}],r=function(){var t=this;t._self._c;return t._m(0)},a=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step1:")]),t._v(" Starting from point 0, update the distance of all points adjacent to 0. At this time, since there are 1 and 2 adjacent to 0, and the distance to these two points is less than the original ∞ distance, so update the distance between these two points and 0 as shown in the figure below. "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",[e("td",[t._v("3")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("4")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],d=s(1001),o={},c=(0,d.Z)(o,r,a,!1,null,"233d3fb0",null),v=c.exports,_=function(){var t=this;t._self._c;return t._m(0)},h=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step2:")]),t._v(" Select A point from set B to add to set A, which should satisfy the shortest distance from point 0, so we select point 2 to add to set A, and then set A becomes: {0,2}, set B becomes: {1,3,4,5,6}, as shown in the following table "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",[e("td",[t._v("3")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("4")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],l={},u=(0,d.Z)(l,_,h,!1,null,"535c7acf",null),p=u.exports,g=function(){var t=this;t._self._c;return t._m(0)},w=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step3:")]),t._v(" Going to take this 2 that I just added, and I'm going to update all the points that are adjacent to 2, because the points that are adjacent to 2 have 3 and 5, and the distance between these two points and 0 is less than the distance infinity between them and 0 "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("3")]),e("td",[t._v("8")])]),e("tr",[e("td",[t._v("4")]),e("td",[t._v("∞")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("5")]),e("td",[t._v("10")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],f={},b=(0,d.Z)(f,g,w,!1,null,"63c978b2",null),m=b.exports,C=function(){var t=this;t._self._c;return t._m(0)},j=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step4:")]),t._v(" Select the point 1 from the set B to add to the set A, because the point 1 is the closest to 0 in the set B, as shown in the figure below, then set A becomes: {0,1,2}, and set B becomes: {3,4,5,6}. "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",[e("td",[t._v("3")]),e("td",[t._v("8")])]),e("tr",[e("td",[t._v("4")]),e("td",[t._v("∞")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("10")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],x={},A=(0,d.Z)(x,C,j,!1,null,"fb3d61e4",null),y=A.exports,k=function(){var t=this;t._self._c;return t._m(0)},D=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step5:")]),t._v(" Going to take the point 1 that I just added, and I'm going to update all the adjacencies of 1, and it's going to have 3 and 4, because the distance from 0 to 3 is 6, which is less than the distance from 0 to 3, which is 8, so the distance from 6 is going to be 6(5+1), and the distance from 0 to 4 is going to be 11 "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("4")]),e("td",[t._v("11")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("10")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],S={},V=(0,d.Z)(S,k,D,!1,null,"4f0cb750",null),q=V.exports,B=function(){var t=this;t._self._c;return t._m(0)},Z=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step6:")]),t._v(" Select A point from set B with the minimum distance from point 0 and add it to set A. At this time, point 3 can be selected, because 3 is the closest to point 0 in set B. At this time, set A becomes: {0,1,2,3}, and set B becomes: {4,5,6}. "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",[e("td",[t._v("4")]),e("td",[t._v("11")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("10")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],I={},E=(0,d.Z)(I,B,Z,!1,null,"a4c71eba",null),L=E.exports,N=function(){var t=this;t._self._c;return t._m(0)},z=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step7:")]),t._v(" So we're going to start at this 3 point that we just picked, we're going to update all of the adjacencies of 3, 3 has 4 and 5, so the distance from 4 to 0 was 11, so 3, when we add this in, the distance from 4 to 0 is 7, which is less than 11, so we're going to update it, and the distance from 5 to 0 was 10, so when we add this in, the distance from 5 to 0 is 8, so we're going to update it "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("4")]),e("td",[t._v("7")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("5")]),e("td",[t._v("8")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],F={},G=(0,d.Z)(F,N,z,!1,null,"0e2ed851",null),T=G.exports,W=function(){var t=this;t._self._c;return t._m(0)},O=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step8:")]),t._v(" We choose A point from set B that is the least distance from 0, so we choose 4, because 4 is the closest to 0, which is 7, so set A becomes: {0,1,2,3,4}, and set B becomes: {5,6} "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("4")]),e("td",[t._v("7")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("8")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("∞")])])])])}],P={},Q=(0,d.Z)(P,W,O,!1,null,"1c793030",null),M=Q.exports,U=function(){var t=this;t._self._c;return t._m(0)},X=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step9:")]),t._v(" We're going to start at the point we just picked, 4, and we're going to update all of its adjacencies, 4 has 6 adjacencies, so the distance from 6 to 0 is infinity, so we're going to add 4 and the distance from 6 to 0 is going to be 14, which is less than infinity, so we're going to update the distance from 6 to 0, so we're going to update it to 11 "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("4")]),e("td",[t._v("7")])]),e("tr",[e("td",[t._v("5")]),e("td",[t._v("8")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("6")]),e("td",[t._v("14")])])])])}],H={},J=(0,d.Z)(H,U,X,!1,null,"326b625e",null),K=J.exports,R=function(){var t=this;t._self._c;return t._m(0)},Y=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step10:")]),t._v(" Select A point from set B that is the shortest distance from point 0 and join the set. At this time, we can choose the point 5, because it is the closest point from point 0 in set B, so set A becomes: {0,1,2,3,4,5}, and set B becomes {6}. "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("4")]),e("td",[t._v("7")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("5")]),e("td",[t._v("8")])]),e("tr",[e("td",[t._v("6")]),e("td",[t._v("14")])])])])}],$={},tt=(0,d.Z)($,R,Y,!1,null,"bbcbbcee",null),et=tt.exports,st=function(){var t=this;t._self._c;return t._m(0)},nt=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step11:")]),t._v(" So if we start at this point that we just picked, which is the point 5, we update all of its neighbors, so the neighbor of 5 is 6, so the distance from 0 to 6 was 14, and when we add in the point 5, the distance from 0 to 6 becomes 11, so we need to update the distance from 0 to 6 "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("4")]),e("td",[t._v("7")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("5")]),e("td",[t._v("8")])]),e("tr",{staticClass:"red-border"},[e("td",[t._v("6")]),e("td",[t._v("11")])])])])}],it={},rt=(0,d.Z)(it,st,nt,!1,null,"081d410c",null),at=rt.exports,dt=function(){var t=this;t._self._c;return t._m(0)},ot=[function(){var t=this,e=t._self._c;return e("div",[e("h3",[t._v("Step12:")]),t._v(" Since there is only one point left in set B, which is point 6, it can be directly added to set A, then set A becomes :{0,1,2,3,4,5,6}, and set B becomes :{}. At this point, the shortest path from point 0 to all other points has been calculated, which is shown in the following table "),e("table",[e("tr",{staticClass:"blue-row"},[e("td",[t._v("Vertex number")]),e("td",[t._v("Distance to source")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("0")]),e("td",[t._v("0")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("1")]),e("td",[t._v("5")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("2")]),e("td",[t._v("2")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("3")]),e("td",[t._v("6")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("4")]),e("td",[t._v("7")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("5")]),e("td",[t._v("8")])]),e("tr",{staticClass:"green-row"},[e("td",[t._v("6")]),e("td",[t._v("11")])])])])}],ct={},vt=(0,d.Z)(ct,dt,ot,!1,null,"e8c85cae",null),_t=vt.exports,ht=function(){var t=this,e=t._self._c;return e("div",[e("pre",{directives:[{name:"highlightA",rawName:"v-highlightA"}]},[t._v("        "),e("code",{staticClass:"cpp"},[t._v("\n            "+t._s(t.code)+"\n        ")]),t._v("\n    ")])])},lt=[],ut={data(){return{code:"\nstruct Edge {\n    int destination;\n    int weight;\n};\n\ntypedef std::vector<std::vector<Edge>> Graph;\n\nstd::vector<int> Dijkstra(const Graph& graph, int source) {\n    int numVertices = graph.size();\n    std::vector<int> distances(numVertices, INF);\n    distances[source] = 0;\n\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\n    pq.push(std::make_pair(0, source));\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n\n        for (const Edge& edge : graph[u]) {\n            int v = edge.destination;\n            int weight = edge.weight;\n\n            if (distances[v] > distances[u] + weight) {\n                distances[v] = distances[u] + weight;\n                pq.push(std::make_pair(distances[v], v));\n            }\n        }\n    }\n\n    return distances;\n}\n            "}}},pt=ut,gt=(0,d.Z)(pt,ht,lt,!1,null,"2d56ecf9",null),wt=gt.exports,ft=function(){var t=this,e=t._self._c;return e("div",[e("pre",{directives:[{name:"highlightA",rawName:"v-highlightA"}]},[t._v("        "),e("code",{staticClass:"java"},[t._v("\n            "+t._s(t.code)+"\n        ")]),t._v("\n    ")])])},bt=[],mt={data(){return{code:"\nclass Edge {\n    int destination;\n    int weight;\n\n    public Edge(int destination, int weight) {\n        this.destination = destination;\n        this.weight = weight;\n    }\n}\n\npublic class Dijkstra {\n    static final int INF = Integer.MAX_VALUE;\n\n    public static List<Integer> dijkstra(List<List<Edge>> graph, int source) {\n        int numVertices = graph.size();\n        int[] distances = new int[numVertices];\n        Arrays.fill(distances, INF);\n        distances[source] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        pq.offer(new int[]{0, source});\n\n        while (!pq.isEmpty()) {\n            int[] node = pq.poll();\n            int dist = node[0];\n            int u = node[1];\n\n            if (dist > distances[u]) {\n                continue;\n            }\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.destination;\n                int weight = edge.weight;\n\n                if (distances[v] > distances[u] + weight) {\n                    distances[v] = distances[u] + weight;\n                    pq.offer(new int[]{distances[v], v});\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numVertices; i++) {\n            result.add(distances[i]);\n        }\n        return result;\n    }\n            "}}},Ct=mt,jt=(0,d.Z)(Ct,ft,bt,!1,null,"28b84df9",null),xt=jt.exports,At=function(){var t=this,e=t._self._c;return e("div",[e("pre",{directives:[{name:"highlightA",rawName:"v-highlightA"}]},[t._v("        "),e("code",{staticClass:"python"},[t._v("\n            "+t._s(t.code)+"\n        ")]),t._v("\n    ")])])},yt=[],kt={data(){return{code:"\ndef dijkstra(graph: List[List[Tuple[int, int]]], source: int) -> List[int]:\n    num_vertices = len(graph)\n    distances = [INF] * num_vertices\n    distances[source] = 0\n\n    pq = [(0, source)]\n\n    while pq:\n        dist, u = heapq.heappop(pq)\n\n        if dist > distances[u]:\n            continue\n\n        for v, weight in graph[u]:\n            if distances[v] > distances[u] + weight:\n                distances[v] = distances[u] + weight\n                heapq.heappush(pq, (distances[v], v))\n\n    return distances\n\n            "}}},Dt=kt,St=(0,d.Z)(Dt,At,yt,!1,null,"0f469c82",null),Vt=St.exports,qt={components:{step1:v,step2:p,step3:m,step4:y,step5:q,step6:L,step7:T,step8:M,step9:K,step10:et,step11:at,step12:_t,dij_cpp:wt,dij_java:xt,dij_python:Vt}},Bt=qt,Zt=(0,d.Z)(Bt,n,i,!1,null,"1efe1ef2",null),It=Zt.exports},36231:function(t,e,s){t.exports=s.p+"img/dij.b3a64e1d.gif"},49434:function(t,e,s){t.exports=s.p+"img/dij_note.775f3587.png"}}]);
//# sourceMappingURL=278.08f923f8.js.map