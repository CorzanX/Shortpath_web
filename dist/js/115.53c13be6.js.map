{"version":3,"file":"js/115.53c13be6.js","mappings":"2JAAA,IAAIA,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACA,EAAG,KAAK,CAACF,EAAII,GAAG,kBAAkBF,EAAG,IAAI,CAACF,EAAII,GAAG,yWAAyWF,EAAG,KAAK,CAACF,EAAII,GAAG,qCAAqCJ,EAAII,GAAG,glCAAglCF,EAAG,MAAMF,EAAII,GAAG,uBAAuBF,EAAG,MAAMA,EAAG,MAAM,CAACG,MAAM,CAAC,IAAMC,EAAQ,OAA+B,MAAQ,SAASJ,EAAG,MAAMF,EAAII,GAAG,yUAAyUF,EAAG,MAAMA,EAAG,MAAM,CAACG,MAAM,CAAC,IAAMC,EAAQ,IAAuB,MAAQ,SAASJ,EAAG,MAAMA,EAAG,KAAK,CAACF,EAAII,GAAG,eAAeF,EAAG,KAAK,CAACF,EAAII,GAAG,SAASF,EAAG,UAAUA,EAAG,KAAK,CAACF,EAAII,GAAG,UAAUF,EAAG,WAAWA,EAAG,KAAK,CAACF,EAAII,GAAG,YAAYF,EAAG,UAAU,EAC1zE,EACIK,EAAkB,GCFlBR,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACA,EAAG,MAAM,CAACM,WAAW,CAAC,CAACC,KAAK,aAAaC,QAAQ,kBAAkB,CAACV,EAAII,GAAG,YAAYF,EAAG,OAAO,CAACS,YAAY,OAAO,CAACX,EAAII,GAAG,iBAAiBJ,EAAIY,GAAGZ,EAAIa,MAAM,gBAAgBb,EAAII,GAAG,aACnQ,EACIG,EAAkB,GCUtB,GACAO,OACA,OACAD,KAAA,kvCAyCA,GCxDwQ,I,UCQpQE,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIF,EAAeA,EAAiB,QCnB5BhB,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACA,EAAG,MAAM,CAACM,WAAW,CAAC,CAACC,KAAK,aAAaC,QAAQ,kBAAkB,CAACV,EAAII,GAAG,YAAYF,EAAG,OAAO,CAACS,YAAY,QAAQ,CAACX,EAAII,GAAG,iBAAiBJ,EAAIY,GAAGZ,EAAIa,MAAM,gBAAgBb,EAAII,GAAG,aACpQ,EACIG,EAAkB,GCUtB,GACAO,OACA,OACAD,KAAA,igDAiDA,GChEyQ,ICQrQ,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIF,EAAe,EAAiB,QCnB5Bd,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACA,EAAG,MAAM,CAACM,WAAW,CAAC,CAACC,KAAK,aAAaC,QAAQ,kBAAkB,CAACV,EAAII,GAAG,YAAYF,EAAG,OAAO,CAACS,YAAY,UAAU,CAACX,EAAII,GAAG,iBAAiBJ,EAAIY,GAAGZ,EAAIa,MAAM,gBAAgBb,EAAII,GAAG,aACtQ,EACIG,EAAkB,GCUtB,GACAO,OACA,OACAD,KAAA,+wBA0BA,GCzCuQ,ICQnQ,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIF,EAAe,EAAiB,QCShC,GACAG,WAAA,CACAC,OAAA,EACAC,QAAA,EACAC,MAAAA,IChCoQ,ICQhQ,GAAY,OACd,EACApB,EACAQ,GACA,EACA,KACA,WACA,MAIF,EAAe,EAAiB,O","sources":["webpack://corzanx/./src/components/Introduction/AlgIntro_bf.vue","webpack://corzanx/./src/components/Introduction/bf/bf_cpp.vue","webpack://corzanx/src/components/Introduction/bf/bf_cpp.vue","webpack://corzanx/./src/components/Introduction/bf/bf_cpp.vue?cdc8","webpack://corzanx/./src/components/Introduction/bf/bf_cpp.vue?078d","webpack://corzanx/./src/components/Introduction/bf/bf_java.vue","webpack://corzanx/src/components/Introduction/bf/bf_java.vue","webpack://corzanx/./src/components/Introduction/bf/bf_java.vue?2bfd","webpack://corzanx/./src/components/Introduction/bf/bf_java.vue?e241","webpack://corzanx/./src/components/Introduction/bf/bf_py.vue","webpack://corzanx/src/components/Introduction/bf/bf_py.vue","webpack://corzanx/./src/components/Introduction/bf/bf_py.vue?023f","webpack://corzanx/./src/components/Introduction/bf/bf_py.vue?93a8","webpack://corzanx/src/components/Introduction/AlgIntro_bf.vue","webpack://corzanx/./src/components/Introduction/AlgIntro_bf.vue?e204","webpack://corzanx/./src/components/Introduction/AlgIntro_bf.vue?710e"],"sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_c('h1',[_vm._v(\"Bellman-Ford\")]),_c('p',[_vm._v(\"The American applied mathematician Richard Bellman (Richard. Behrman, the author of dynamic programming, published the algorithm in 1958. Lester Ford also published this algorithm in 1956. So this algorithm is called Bellman-Ford. In fact, EdwardF. Moore published the same algorithm in 1957, so this algorithm is also called Bellman-Ford-Moore algorithm.\")]),_c('h2',[_vm._v(\"The realization of Bellman-Ford\")]),_vm._v(\" Like Dijkstra's algorithm, Bellman–Ford proceeds by relaxation, in which approximations to the correct distance are replaced by better ones until they eventually reach the solution. In both algorithms, the approximate distance to each vertex is always an overestimate of the true distance, and is replaced by the minimum of its old value and the length of a newly found path. However, Dijkstra's algorithm uses a priority queue to greedily select the closest vertex that has not yet been processed, and performs this relaxation process on all of its outgoing edges; by contrast, the Bellman–Ford algorithm simply relaxes all the edges, and does this |V|-1 times, where |V| is the number of vertices in the graph. In each of these repetitions, the number of vertices with correctly calculated distances grows, from which it follows that eventually all vertices will have their correct distances. This method allows the Bellman–Ford algorithm to be applied to a wider class of inputs than Dijkstra. The intermediate answers depend on the order of edges relaxed, but the final answer remains the same. \"),_c('br'),_vm._v(\" There is a exmaple\"),_c('br'),_c('img',{attrs:{\"src\":require(\"../../assets/bm_example.gif\"),\"width\":\"60%\"}}),_c('br'),_vm._v(\" In this example graph, assuming that A is the source and edges are processed in the worst order, from right to left, it requires the full |V|−1 or 4 iterations for the distance estimates to converge. Conversely, if the edges are processed in the best order, from left to right, the algorithm converges in a single iteration.\"),_c('br'),_c('img',{attrs:{\"src\":require(\"../../assets/bm.png\"),\"width\":\"60%\"}}),_c('br'),_c('h2',[_vm._v(\"Core Code\")]),_c('h3',[_vm._v(\"cpp\")]),_c('bf_cpp'),_c('h3',[_vm._v(\"java\")]),_c('bf_java'),_c('h3',[_vm._v(\"python\")]),_c('bf_py')],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_c('pre',{directives:[{name:\"highlightA\",rawName:\"v-highlightA\"}]},[_vm._v(\"        \"),_c('code',{staticClass:\"cpp\"},[_vm._v(\"\\n            \"+_vm._s(_vm.code)+\"\\n        \")]),_vm._v(\"\\n    \")])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div>\n        <pre v-highlightA>\n            <code class=\"cpp\">\n                {{code}}\n            </code>\n        </pre>\n    </div>\n</template>\n\n<script>\n\nexport default {\n    data(){\n        return {\ncode:`\nstruct Edge {\n    int source, destination, weight;\n};\n\nvoid bellmanFord(std::vector<Edge>& edges, int numVertices, int source) {\n    std::vector<int> distance(numVertices, std::numeric_limits<int>::max());\n    distance[source] = 0;\n\n    for (int i = 1; i <= numVertices - 1; ++i) {\n        for (const auto& edge : edges) {\n            int u = edge.source;\n            int v = edge.destination;\n            int weight = edge.weight;\n\n            if (distance[u] != std::numeric_limits<int>::max() && distance[u] + weight < distance[v]) {\n                distance[v] = distance[u] + weight;\n            }\n        }\n    }\n\n    // Detect negative weight loops\n    for (const auto& edge : edges) {\n        int u = edge.source;\n        int v = edge.destination;\n        int weight = edge.weight;\n\n        if (distance[u] != std::numeric_limits<int>::max() && distance[u] + weight < distance[v]) {\n            std::cout << \"There are negative weight loops in the graph!\" << std::endl;\n            return;\n        }\n    }\n\n    // output shortest path\n    std::cout << \"Vertice\\tshortest path\" << std::endl;\n    for (int i = 0; i < numVertices; ++i) {\n        std::cout << i << \"\\t\" << distance[i] << std::endl;\n    }\n}\n            `\n        }\n    }\n}\n</script>\n\n<style scoped>\npre {\n  background-color: #f4f4f4;\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-family: Consolas, Monaco, 'Andale Mono', monospace;\n  font-size: 14px;\n}\n\ncode {\n  font-family: Consolas, Monaco, 'Andale Mono', monospace;\n  font-size: 14px;\n}\n\n</style>","import mod from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./bf_cpp.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./bf_cpp.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./bf_cpp.vue?vue&type=template&id=20ea4150&scoped=true&\"\nimport script from \"./bf_cpp.vue?vue&type=script&lang=js&\"\nexport * from \"./bf_cpp.vue?vue&type=script&lang=js&\"\nimport style0 from \"./bf_cpp.vue?vue&type=style&index=0&id=20ea4150&prod&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"20ea4150\",\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_c('pre',{directives:[{name:\"highlightA\",rawName:\"v-highlightA\"}]},[_vm._v(\"        \"),_c('code',{staticClass:\"java\"},[_vm._v(\"\\n            \"+_vm._s(_vm.code)+\"\\n        \")]),_vm._v(\"\\n    \")])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div>\n        <pre v-highlightA>\n            <code class=\"java\">\n                {{code}}\n            </code>\n        </pre>\n    </div>\n</template>\n\n<script>\n\nexport default {\n    data(){\n        return {\ncode:`\nclass Edge {\n    int source, destination, weight;\n\n    public Edge(int source, int destination, int weight) {\n        this.source = source;\n        this.destination = destination;\n        this.weight = weight;\n    }\n}\n\npublic class BellmanFord {\n    public static void bellmanFord(Edge[] edges, int numVertices, int source) {\n        int[] distance = new int[numVertices];\n        Arrays.fill(distance, Integer.MAX_VALUE);\n        distance[source] = 0;\n\n        for (int i = 1; i <= numVertices - 1; ++i) {\n            for (Edge edge : edges) {\n                int u = edge.source;\n                int v = edge.destination;\n                int weight = edge.weight;\n\n                if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {\n                    distance[v] = distance[u] + weight;\n                }\n            }\n        }\n\n        // Detect negative weight loops\n        for (Edge edge : edges) {\n            int u = edge.source;\n            int v = edge.destination;\n            int weight = edge.weight;\n\n            if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {\n                System.out.println(\"There are negative weight loops in the graph!\");\n                return;\n            }\n        }\n\n        // output shortest path\n        System.out.println(\"Vertice\\tshortest path\");\n        for (int i = 0; i < numVertices; ++i) {\n            System.out.println(i + \"\\t\" + distance[i]);\n        }\n    }\n            `\n        }\n    }\n}\n</script>\n\n<style scoped>\npre {\n  background-color: #f4f4f4;\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-family: Consolas, Monaco, 'Andale Mono', monospace;\n  font-size: 14px;\n}\n\ncode {\n  font-family: Consolas, Monaco, 'Andale Mono', monospace;\n  font-size: 14px;\n}\n\n</style>","import mod from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./bf_java.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./bf_java.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./bf_java.vue?vue&type=template&id=40968b79&scoped=true&\"\nimport script from \"./bf_java.vue?vue&type=script&lang=js&\"\nexport * from \"./bf_java.vue?vue&type=script&lang=js&\"\nimport style0 from \"./bf_java.vue?vue&type=style&index=0&id=40968b79&prod&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"40968b79\",\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_c('pre',{directives:[{name:\"highlightA\",rawName:\"v-highlightA\"}]},[_vm._v(\"        \"),_c('code',{staticClass:\"python\"},[_vm._v(\"\\n            \"+_vm._s(_vm.code)+\"\\n        \")]),_vm._v(\"\\n    \")])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div>\n        <pre v-highlightA>\n            <code class=\"python\">\n                {{code}}\n            </code>\n        </pre>\n    </div>\n</template>\n\n<script>\n\nexport default {\n    data(){\n        return {\ncode:`\ndef bellman_ford(edges, num_vertices, source):\n    distance = [float('inf')] * num_vertices\n    distance[source] = 0\n\n    for _ in range(num_vertices - 1):\n        for edge in edges:\n            u, v, weight = edge\n\n            if distance[u] != float('inf') and distance[u] + weight < distance[v]:\n                distance[v] = distance[u] + weight\n\n    # Detect negative weight loops\n    for edge in edges:\n        u, v, weight = edge\n\n        if distance[u] != float('inf') and distance[u] + weight < distance[v]:\n            print(\"There are negative weight loops in the graph!\")\n            return\n\n    # output shortest path\n    print(\"Vertice\\tshortest path\")\n    for i in range(num_vertices):\n        print(i, \"\\t\", distance[i])\n            `\n        }\n    }\n}\n</script>\n\n<style scoped>\npre {\n  background-color: #f4f4f4;\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-family: Consolas, Monaco, 'Andale Mono', monospace;\n  font-size: 14px;\n}\n\ncode {\n  font-family: Consolas, Monaco, 'Andale Mono', monospace;\n  font-size: 14px;\n}\n\n</style>","import mod from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./bf_py.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./bf_py.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./bf_py.vue?vue&type=template&id=096560fa&scoped=true&\"\nimport script from \"./bf_py.vue?vue&type=script&lang=js&\"\nexport * from \"./bf_py.vue?vue&type=script&lang=js&\"\nimport style0 from \"./bf_py.vue?vue&type=style&index=0&id=096560fa&prod&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"096560fa\",\n  null\n  \n)\n\nexport default component.exports","<template>\n    <div>\n        <h1>Bellman-Ford</h1>\n        <p>The American applied mathematician Richard Bellman (Richard. Behrman, the author of dynamic programming, published the algorithm in 1958. Lester Ford also published this algorithm in 1956. So this algorithm is called Bellman-Ford. In fact, EdwardF. Moore published the same algorithm in 1957, so this algorithm is also called Bellman-Ford-Moore algorithm.</p>\n        <h2>The realization of Bellman-Ford</h2>\n        Like Dijkstra's algorithm, Bellman–Ford proceeds by relaxation, in which approximations to the correct distance are replaced by better ones until they eventually reach the solution. In both algorithms, the approximate distance to each vertex is always an overestimate of the true distance, and is replaced by the minimum of its old value and the length of a newly found path. However, Dijkstra's algorithm uses a priority queue to greedily select the closest vertex that has not yet been processed, and performs this relaxation process on all of its outgoing edges; by contrast, the Bellman–Ford algorithm simply relaxes all the edges, and does this |V|-1 times, where |V| is the number of vertices in the graph. In each of these repetitions, the number of vertices with correctly calculated distances grows, from which it follows that eventually all vertices will have their correct distances. This method allows the Bellman–Ford algorithm to be applied to a wider class of inputs than Dijkstra. The intermediate answers depend on the order of edges relaxed, but the final answer remains the same.\n        <br>\n        There is a exmaple<br>\n        <img src=\"../../assets/bm_example.gif\" width=\"60%\"><br>\n        In this example graph, assuming that A is the source and edges are processed in the worst order, from right to left, it requires the full |V|−1 or 4 iterations for the distance estimates to converge. Conversely, if the edges are processed in the best order, from left to right, the algorithm converges in a single iteration.<br>\n        <img src=\"../../assets/bm.png\" width=\"60%\"><br>\n        \n\n        <h2>Core Code</h2>\n        <h3>cpp</h3>\n        <bf_cpp/>\n        <h3>java</h3>\n        <bf_java/>\n        <h3>python</h3>\n        <bf_py/>\n    </div>\n</template>\n\n\n<script>\nimport bf_cpp from './bf/bf_cpp.vue' \nimport bf_java from './bf/bf_java.vue' \nimport bf_py from './bf/bf_py.vue' \nexport default {\n    components:{\n        bf_cpp,\n        bf_java,\n        bf_py\n    }\n}\n</script>\n\n\n\n<style scoped>\n    h1{\n        font-size: 30px;\n    }\n    h2{\n        font-size: 20px;\n    }\n    h3{\n        font-size: 17px;\n    }\n    \n    \n</style>","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./AlgIntro_bf.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./AlgIntro_bf.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./AlgIntro_bf.vue?vue&type=template&id=38fa8f05&scoped=true&\"\nimport script from \"./AlgIntro_bf.vue?vue&type=script&lang=js&\"\nexport * from \"./AlgIntro_bf.vue?vue&type=script&lang=js&\"\nimport style0 from \"./AlgIntro_bf.vue?vue&type=style&index=0&id=38fa8f05&prod&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"38fa8f05\",\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_c","_self","_v","attrs","require","staticRenderFns","directives","name","rawName","staticClass","_s","code","data","component","components","bf_cpp","bf_java","bf_py"],"sourceRoot":""}