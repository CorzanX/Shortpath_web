{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"highlighted\")) data.highlighted = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */function (_super) {\n  __extends(Sigma, _super);\n  function Sigma(graph, container, settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.elements = {};\n    _this.canvasContexts = {};\n    _this.webGLContexts = {};\n    _this.activeListeners = {};\n    _this.quadtree = new quadtree_1.default();\n    _this.labelGrid = new labels_1.LabelGrid();\n    _this.nodeDataCache = {};\n    _this.edgeDataCache = {};\n    _this.nodesWithForcedLabels = [];\n    _this.edgesWithForcedLabels = [];\n    _this.nodeExtent = {\n      x: [0, 1],\n      y: [0, 1]\n    };\n    _this.matrix = (0, matrices_1.identity)();\n    _this.invMatrix = (0, matrices_1.identity)();\n    _this.correctionRatio = 1;\n    _this.customBBox = null;\n    _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n      x: [0, 1],\n      y: [0, 1]\n    });\n    // Cache:\n    _this.graphToViewportRatio = 1;\n    // Starting dimensions and pixel ratio\n    _this.width = 0;\n    _this.height = 0;\n    _this.pixelRatio = (0, utils_1.getPixelRatio)();\n    // State\n    _this.displayedNodeLabels = new Set();\n    _this.displayedEdgeLabels = new Set();\n    _this.highlightedNodes = new Set();\n    _this.hoveredNode = null;\n    _this.hoveredEdge = null;\n    _this.renderFrame = null;\n    _this.renderHighlightedNodesFrame = null;\n    _this.needToProcess = false;\n    _this.checkEdgesEventsFrame = null;\n    // Programs\n    _this.nodePrograms = {};\n    _this.nodeHoverPrograms = {};\n    _this.edgePrograms = {};\n    // Resolving settings\n    _this.settings = (0, settings_1.resolveSettings)(settings);\n    // Validating\n    (0, settings_1.validateSettings)(_this.settings);\n    (0, utils_1.validateGraph)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      preserveDrawingBuffer: true\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\");\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n    // Blending\n    for (var key in _this.webGLContexts) {\n      var gl = _this.webGLContexts[key];\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n    }\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n      var NodeHoverProgram = NodeProgramClass;\n      if (type in _this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n      }\n      _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, _this);\n    }\n    for (var type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n      _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n    }\n    // Initial resize\n    _this.resize();\n    // Initializing the camera\n    _this.camera = new camera_1.default();\n    // Binding camera events\n    _this.bindCameraHandlers();\n    // Initializing captors\n    _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n    _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n    // Binding event handlers\n    _this.bindEventHandlers();\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  Sigma.prototype.createCanvas = function (id) {\n    var canvas = (0, utils_1.createElement)(\"canvas\", {\n      position: \"absolute\"\n    }, {\n      class: \"sigma-\".concat(id)\n    });\n    this.elements[id] = canvas;\n    this.container.appendChild(canvas);\n    return canvas;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  Sigma.prototype.createCanvasContext = function (id) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false\n    };\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n    return this;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {Sigma}\n   */\n  Sigma.prototype.createWebGLContext = function (id, options) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = __assign({\n      preserveDrawingBuffer: false,\n      antialias: false\n    }, options || {});\n    var context;\n    // First we try webgl2 for an easy performance boost\n    context = canvas.getContext(\"webgl2\", contextOptions);\n    // Else we fall back to webgl\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n    // Edge, I am looking right at you...\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n    this.webGLContexts[id] = context;\n    return this;\n  };\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindCameraHandlers = function () {\n    var _this = this;\n    this.activeListeners.camera = function () {\n      _this.scheduleRender();\n    };\n    this.camera.on(\"updated\", this.activeListeners.camera);\n    return this;\n  };\n  /**\n   * Method unbinding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.unbindCameraHandlers = function () {\n    this.camera.removeListener(\"updated\", this.activeListeners.camera);\n    return this;\n  };\n  /**\n   * Method that checks whether or not a node collides with a given position.\n   */\n  Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n    var x = _a.x,\n      y = _a.y;\n    var nodeX = _b.x,\n      nodeY = _b.y;\n    return x > nodeX - size && x < nodeX + size && y > nodeY - size && y < nodeY + size && Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size;\n  };\n  /**\n   * Method that returns all nodes in quad at a given position.\n   */\n  Sigma.prototype.getQuadNodes = function (position) {\n    var mouseGraphPosition = this.viewportToFramedGraph(position);\n    return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n  };\n  /**\n   * Method that returns the closest node to a given position.\n   */\n  Sigma.prototype.getNodeAtPosition = function (position) {\n    var x = position.x,\n      y = position.y;\n    var quadNodes = this.getQuadNodes(position);\n    // We will hover the node whose center is closest to mouse\n    var minDistance = Infinity,\n      nodeAtPosition = null;\n    for (var i = 0, l = quadNodes.length; i < l; i++) {\n      var node = quadNodes[i];\n      var data = this.nodeDataCache[node];\n      var nodePosition = this.framedGraphToViewport(data);\n      var size = this.scaleSize(data.size);\n      if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n        var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n        // TODO: sort by min size also for cases where center is the same\n        if (distance < minDistance) {\n          minDistance = distance;\n          nodeAtPosition = node;\n        }\n      }\n    }\n    return nodeAtPosition;\n  };\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindEventHandlers = function () {\n    var _this = this;\n    // Handling window resize\n    this.activeListeners.handleResize = function () {\n      _this.scheduleRender();\n    };\n    window.addEventListener(\"resize\", this.activeListeners.handleResize);\n    // Handling mouse move\n    this.activeListeners.handleMove = function (e) {\n      var baseEvent = {\n        event: e,\n        preventSigmaDefault: function () {\n          e.preventSigmaDefault();\n        }\n      };\n      var nodeToHover = _this.getNodeAtPosition(e);\n      if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (_this.hoveredNode) _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n          node: _this.hoveredNode\n        }));\n        _this.hoveredNode = nodeToHover;\n        _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), {\n          node: nodeToHover\n        }));\n        _this.scheduleHighlightedNodesRender();\n        return;\n      }\n      // Checking if the hovered node is still hovered\n      if (_this.hoveredNode) {\n        var data = _this.nodeDataCache[_this.hoveredNode];\n        var pos = _this.framedGraphToViewport(data);\n        var size = _this.scaleSize(data.size);\n        if (!_this.mouseIsOnNode(e, pos, size)) {\n          var node = _this.hoveredNode;\n          _this.hoveredNode = null;\n          _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n            node: node\n          }));\n          _this.scheduleHighlightedNodesRender();\n          return;\n        }\n      }\n      if (_this.settings.enableEdgeHoverEvents === true) {\n        _this.checkEdgeHoverEvents(baseEvent);\n      } else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n        if (!_this.checkEdgesEventsFrame) _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n          _this.checkEdgeHoverEvents(baseEvent);\n          _this.checkEdgesEventsFrame = null;\n        });\n      }\n    };\n    // Handling click\n    var createMouseListener = function (eventType) {\n      return function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function () {\n            e.preventSigmaDefault();\n          }\n        };\n        var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n        var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n        if (nodeAtPosition) return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), {\n          node: nodeAtPosition\n        }));\n        if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n          var edge = _this.getEdgeAtPoint(e.x, e.y);\n          if (edge) return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), {\n            edge: edge\n          }));\n        }\n        return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n      };\n    };\n    this.activeListeners.handleClick = createMouseListener(\"click\");\n    this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n    this.activeListeners.handleDown = createMouseListener(\"down\");\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n    // TODO\n    // Deal with Touch captor events\n    return this;\n  };\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindGraphHandlers = function () {\n    var _this = this;\n    var graph = this.graph;\n    this.activeListeners.graphUpdate = function () {\n      _this.scheduleRefresh();\n    };\n    this.activeListeners.dropNodeGraphUpdate = function (e) {\n      delete _this.nodeDataCache[e.key];\n      if (_this.hoveredNode === e.key) _this.hoveredNode = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.dropEdgeGraphUpdate = function (e) {\n      delete _this.edgeDataCache[e.key];\n      if (_this.hoveredEdge === e.key) _this.hoveredEdge = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.clearEdgesGraphUpdate = function () {\n      _this.edgeDataCache = {};\n      _this.hoveredEdge = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.clearGraphUpdate = function () {\n      _this.nodeDataCache = {};\n      _this.hoveredNode = null;\n      _this.activeListeners.clearEdgesGraphUpdate();\n    };\n    graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n    return this;\n  };\n  /**\n   * Method used to unbind handlers from the graph.\n   *\n   * @return {undefined}\n   */\n  Sigma.prototype.unbindGraphHandlers = function () {\n    var graph = this.graph;\n    graph.removeListener(\"nodeAdded\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n  };\n  /**\n   * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n    var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n    if (edgeToHover !== this.hoveredEdge) {\n      if (this.hoveredEdge) this.emit(\"leaveEdge\", __assign(__assign({}, payload), {\n        edge: this.hoveredEdge\n      }));\n      if (edgeToHover) this.emit(\"enterEdge\", __assign(__assign({}, payload), {\n        edge: edgeToHover\n      }));\n      this.hoveredEdge = edgeToHover;\n    }\n    return this;\n  };\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n  Sigma.prototype.getEdgeAtPoint = function (x, y) {\n    var e_1, _a;\n    var _this = this;\n    var _b = this,\n      edgeDataCache = _b.edgeDataCache,\n      nodeDataCache = _b.nodeDataCache;\n    // Check first that pixel is colored:\n    // Note that mouse positions must be corrected by pixel ratio to correctly\n    // index the drawing buffer.\n    if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio)) return null;\n    // Check for each edge if it collides with the point:\n    var _c = this.viewportToGraph({\n        x: x,\n        y: y\n      }),\n      graphX = _c.x,\n      graphY = _c.y;\n    // To translate edge thicknesses to the graph system, we observe by how much\n    // the length of a non-null edge is transformed to between the graph system\n    // and the viewport system:\n    var transformationRatio = 0;\n    this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n      var xs = _a.x,\n        ys = _a.y;\n      var xt = _b.x,\n        yt = _b.y;\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n      if (xs !== xt || ys !== yt) {\n        var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n        var _c = _this.graphToViewport({\n            x: xs,\n            y: ys\n          }),\n          vp_xs = _c.x,\n          vp_ys = _c.y;\n        var _d = _this.graphToViewport({\n            x: xt,\n            y: yt\n          }),\n          vp_xt = _d.x,\n          vp_yt = _d.y;\n        var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n        transformationRatio = graphLength / viewportLength;\n        return true;\n      }\n    });\n    // If no non-null edge has been found, return null:\n    if (!transformationRatio) return null;\n    // Now we can look for matching edges:\n    var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n      if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y,\n      // Adapt the edge size to the zoom ratio:\n      _this.scaleSize(edgeDataCache[key].size * transformationRatio))) {\n        return true;\n      }\n    });\n    if (edges.length === 0) return null; // no edges found\n    // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n    var selectedEdge = edges[edges.length - 1];\n    // otherwise select edge with highest zIndex\n    var highestZIndex = -Infinity;\n    try {\n      for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n        var edge = edges_1_1.value;\n        var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n        if (zIndex >= highestZIndex) {\n          selectedEdge = edge;\n          highestZIndex = zIndex;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return selectedEdge;\n  };\n  /**\n   * Method used to process the whole graph's data.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.process = function () {\n    var _this = this;\n    var graph = this.graph;\n    var settings = this.settings;\n    var dimensions = this.getDimensions();\n    var nodeZExtent = [Infinity, -Infinity];\n    var edgeZExtent = [Infinity, -Infinity];\n    // Clearing the quad\n    this.quadtree.clear();\n    // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n    // Clear the highlightedNodes\n    this.highlightedNodes = new Set();\n    // Computing extents\n    this.nodeExtent = (0, utils_1.graphExtent)(graph);\n    // Resetting `forceLabel` indices\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n    var nullCamera = new camera_1.default();\n    var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n    // Rescaling function\n    this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n    var nodesPerPrograms = {};\n    var nodes = graph.nodes();\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      // Node display data resolution:\n      //   1. First we get the node's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      //   4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, graph.getNodeAttributes(node));\n      if (settings.nodeReducer) attr = settings.nodeReducer(node, attr);\n      var data = applyNodeDefaults(this.settings, node, attr);\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      this.nodeDataCache[node] = data;\n      this.normalizationFunction.applyTo(data);\n      if (data.forceLabel) this.nodesWithForcedLabels.push(node);\n      if (this.settings.zIndex) {\n        if (data.zIndex < nodeZExtent[0]) nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > nodeZExtent[1]) nodeZExtent[1] = data.zIndex;\n      }\n    }\n    for (var type in this.nodePrograms) {\n      if (!this.nodePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n      }\n      this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      nodesPerPrograms[type] = 0;\n    }\n    // Handling node z-index\n    // TODO: z-index needs us to compute display data before hand\n    if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1]) nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) {\n      return _this.nodeDataCache[node].zIndex;\n    }, nodes);\n    var normalizationRatio = this.normalizationFunction.ratio;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      var data = this.nodeDataCache[node];\n      this.quadtree.add(node, data.x, 1 - data.y, this.scaleSize(data.size, 1) / normalizationRatio);\n      if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n        matrix: nullCameraMatrix\n      }));\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(nodesPerPrograms[data.type]++, data);\n      // Save the node in the highlighted set if needed\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(node);\n    }\n    this.labelGrid.organize();\n    var edgesPerPrograms = {};\n    var edges = graph.edges();\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      // Edge display data resolution:\n      //   1. First we get the edge's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n      if (settings.edgeReducer) attr = settings.edgeReducer(edge, attr);\n      var data = applyEdgeDefaults(this.settings, edge, attr);\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n      this.edgeDataCache[edge] = data;\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.push(edge);\n      if (this.settings.zIndex) {\n        if (data.zIndex < edgeZExtent[0]) edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > edgeZExtent[1]) edgeZExtent[1] = data.zIndex;\n      }\n    }\n    for (var type in this.edgePrograms) {\n      if (!this.edgePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n      }\n      this.edgePrograms[type].reallocate(edgesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      edgesPerPrograms[type] = 0;\n    }\n    // Handling edge z-index\n    if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1]) edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) {\n      return _this.edgeDataCache[edge].zIndex;\n    }, edges);\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      var data = this.edgeDataCache[edge];\n      var extremities = graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      this.edgePrograms[data.type].process(edgesPerPrograms[data.type]++, sourceData, targetData, data);\n    }\n    return this;\n  };\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n  Sigma.prototype.handleSettingsUpdate = function () {\n    this.camera.minRatio = this.settings.minCameraRatio;\n    this.camera.maxRatio = this.settings.maxCameraRatio;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n    return this;\n  };\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderLabels = function () {\n    if (!this.settings.renderLabels) return this;\n    var cameraState = this.camera.getState();\n    // Selecting labels to draw\n    var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n    (0, extend_1.default)(labelsToDisplay, this.nodesWithForcedLabels);\n    this.displayedNodeLabels = new Set();\n    // Drawing labels\n    var context = this.canvasContexts.labels;\n    for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n      var node = labelsToDisplay[i];\n      var data = this.nodeDataCache[node];\n      // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      // NOTE: we can do better probably\n      if (this.displayedNodeLabels.has(node)) continue;\n      // If the node is hidden, we don't need to display its label obviously\n      if (data.hidden) continue;\n      var _a = this.framedGraphToViewport(data),\n        x = _a.x,\n        y = _a.y;\n      // NOTE: we can cache the labels we need to render until the camera's ratio changes\n      var size = this.scaleSize(data.size);\n      // Is node big enough?\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n      // Is node actually on screen (with some margin)\n      // NOTE: we used to rely on the quadtree for this, but the coordinates\n      // conversion make it unreliable and at that point we already converted\n      // to viewport coordinates and since the label grid already culls the\n      // number of potential labels to display this looks like a good\n      // performance compromise.\n      // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n      // considering cells obviously outside of the range of the current\n      // view rectangle.\n      if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedNodeLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedNodeLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n      this.displayedNodeLabels.add(node);\n      this.settings.labelRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), this.settings);\n    }\n    return this;\n  };\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderEdgeLabels = function () {\n    if (!this.settings.renderEdgeLabels) return this;\n    var context = this.canvasContexts.edgeLabels;\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n    var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedNodeLabels,\n      highlightedNodes: this.highlightedNodes\n    }).concat(this.edgesWithForcedLabels);\n    var displayedLabels = new Set();\n    for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      var edge = edgeLabelsToDisplay[i],\n        extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]],\n        edgeData = this.edgeDataCache[edge];\n      // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (displayedLabels.has(edge)) continue;\n      // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n      this.settings.edgeLabelRenderer(context, __assign(__assign({\n        key: edge\n      }, edgeData), {\n        size: this.scaleSize(edgeData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[0]\n      }, sourceData), this.framedGraphToViewport(sourceData)), {\n        size: this.scaleSize(sourceData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[1]\n      }, targetData), this.framedGraphToViewport(targetData)), {\n        size: this.scaleSize(targetData.size)\n      }), this.settings);\n      displayedLabels.add(edge);\n    }\n    this.displayedEdgeLabels = displayedLabels;\n    return this;\n  };\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderHighlightedNodes = function () {\n    var _this = this;\n    var context = this.canvasContexts.hovers;\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n    // Rendering\n    var render = function (node) {\n      var data = _this.nodeDataCache[node];\n      var _a = _this.framedGraphToViewport(data),\n        x = _a.x,\n        y = _a.y;\n      var size = _this.scaleSize(data.size);\n      _this.settings.hoverRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), _this.settings);\n    };\n    var nodesToRender = [];\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n    this.highlightedNodes.forEach(function (node) {\n      // The hovered node has already been highlighted\n      if (node !== _this.hoveredNode) nodesToRender.push(node);\n    });\n    // Draw labels:\n    nodesToRender.forEach(function (node) {\n      return render(node);\n    });\n    // Draw WebGL nodes on top of the labels:\n    var nodesPerPrograms = {};\n    // 1. Count nodes per type:\n    nodesToRender.forEach(function (node) {\n      var type = _this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    });\n    // 2. Allocate for each type for the proper number of nodes\n    for (var type in this.nodeHoverPrograms) {\n      this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // Also reset count, to use when rendering:\n      nodesPerPrograms[type] = 0;\n    }\n    // 3. Process all nodes to render:\n    nodesToRender.forEach(function (node) {\n      var data = _this.nodeDataCache[node];\n      _this.nodeHoverPrograms[data.type].process(nodesPerPrograms[data.type]++, data);\n    });\n    // 4. Clear hovered nodes layer:\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    // 5. Render:\n    for (var type in this.nodeHoverPrograms) {\n      var program = this.nodeHoverPrograms[type];\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio\n      });\n    }\n  };\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n  Sigma.prototype.scheduleHighlightedNodesRender = function () {\n    var _this = this;\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n    this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n      // Resetting state\n      _this.renderHighlightedNodesFrame = null;\n      // Rendering\n      _this.renderHighlightedNodes();\n      _this.renderEdgeLabels();\n    });\n  };\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.render = function () {\n    var _this = this;\n    this.emit(\"beforeRender\");\n    var exitRender = function () {\n      _this.emit(\"afterRender\");\n      return _this;\n    };\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n    }\n    // First we need to resize\n    this.resize();\n    // Do we need to reprocess data?\n    if (this.needToProcess) this.process();\n    this.needToProcess = false;\n    // Clearing the canvases\n    this.clear();\n    // If we have no nodes we can stop right there\n    if (!this.graph.order) return exitRender();\n    // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n    var mouseCaptor = this.mouseCaptor;\n    var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n    // Then we need to extract a matrix from the camera\n    var cameraState = this.camera.getState();\n    var viewportDimensions = this.getDimensions();\n    var graphDimensions = this.getGraphDimensions();\n    var padding = this.getSetting(\"stagePadding\") || 0;\n    this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n    this.graphToViewportRatio = this.getGraphToViewportRatio();\n    // [jacomyal]\n    // This comment is related to the one above the `getMatrixImpact` definition:\n    // - `this.correctionRatio` is somehow not completely explained\n    // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n    //   graph\n    // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n    // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n    // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n    // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n    var params = {\n      matrix: this.matrix,\n      width: this.width,\n      height: this.height,\n      pixelRatio: this.pixelRatio,\n      zoomRatio: this.camera.ratio,\n      sizeRatio: 1 / this.scaleSize(),\n      correctionRatio: this.correctionRatio\n    };\n    // Drawing nodes\n    for (var type in this.nodePrograms) {\n      var program = this.nodePrograms[type];\n      program.render(params);\n    }\n    // Drawing edges\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (var type in this.edgePrograms) {\n        var program = this.edgePrograms[type];\n        program.render(params);\n      }\n    }\n    // Do not display labels on move per setting\n    if (this.settings.hideLabelsOnMove && moving) return exitRender();\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n    return exitRender();\n  };\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n  Sigma.prototype.getCamera = function () {\n    return this.camera;\n  };\n  /**\n   * Method setting the renderer's camera.\n   *\n   * @param  {Camera} camera - New camera.\n   * @return {Sigma}\n   */\n  Sigma.prototype.setCamera = function (camera) {\n    this.unbindCameraHandlers();\n    this.camera = camera;\n    this.bindCameraHandlers();\n  };\n  /**\n   * Method returning the container DOM element.\n   *\n   * @return {HTMLElement}\n   */\n  Sigma.prototype.getContainer = function () {\n    return this.container;\n  };\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  Sigma.prototype.getGraph = function () {\n    return this.graph;\n  };\n  /**\n   * Method used to set the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  Sigma.prototype.setGraph = function (graph) {\n    if (graph === this.graph) return;\n    // Unbinding handlers on the current graph\n    this.unbindGraphHandlers();\n    // Clearing the graph data caches\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n    // Cleaning renderer state tied to the current graph\n    this.displayedNodeLabels.clear();\n    this.displayedEdgeLabels.clear();\n    this.highlightedNodes.clear();\n    this.hoveredNode = null;\n    this.hoveredEdge = null;\n    this.nodesWithForcedLabels.length = 0;\n    this.edgesWithForcedLabels.length = 0;\n    if (this.checkEdgesEventsFrame !== null) {\n      (0, utils_1.cancelFrame)(this.checkEdgesEventsFrame);\n      this.checkEdgesEventsFrame = null;\n    }\n    // Installing new graph\n    this.graph = graph;\n    // Binding new handlers\n    this.bindGraphHandlers();\n    // Re-rendering now to avoid discrepancies from now to next frame\n    this.refresh();\n  };\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n  Sigma.prototype.getMouseCaptor = function () {\n    return this.mouseCaptor;\n  };\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n  Sigma.prototype.getTouchCaptor = function () {\n    return this.touchCaptor;\n  };\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  Sigma.prototype.getDimensions = function () {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  };\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  Sigma.prototype.getGraphDimensions = function () {\n    var extent = this.customBBox || this.nodeExtent;\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1\n    };\n  };\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's usefull for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n  Sigma.prototype.getNodeDisplayData = function (key) {\n    var node = this.nodeDataCache[key];\n    return node ? Object.assign({}, node) : undefined;\n  };\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's usefull for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n  Sigma.prototype.getEdgeDisplayData = function (key) {\n    var edge = this.edgeDataCache[key];\n    return edge ? Object.assign({}, edge) : undefined;\n  };\n  /**\n   * Method used to get the set of currently displayed node labels.\n   *\n   * @return {Set<string>} A set of node keys whose label is displayed.\n   */\n  Sigma.prototype.getNodeDisplayedLabels = function () {\n    return new Set(this.displayedNodeLabels);\n  };\n  /**\n   * Method used to get the set of currently displayed edge labels.\n   *\n   * @return {Set<string>} A set of edge keys whose label is displayed.\n   */\n  Sigma.prototype.getEdgeDisplayedLabels = function () {\n    return new Set(this.displayedEdgeLabels);\n  };\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n  Sigma.prototype.getSettings = function () {\n    return __assign({}, this.settings);\n  };\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n  Sigma.prototype.getSetting = function (key) {\n    return this.settings[key];\n  };\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n  Sigma.prototype.setSetting = function (key, value) {\n    this.settings[key] = value;\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n  Sigma.prototype.updateSetting = function (key, updater) {\n    this.settings[key] = updater(this.settings[key]);\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to resize the renderer.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.resize = function () {\n    var previousWidth = this.width,\n      previousHeight = this.height;\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.pixelRatio = (0, utils_1.getPixelRatio)();\n    if (this.width === 0) {\n      if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n    }\n    if (this.height === 0) {\n      if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n    }\n    // If nothing has changed, we can stop right here\n    if (previousWidth === this.width && previousHeight === this.height) return this;\n    this.emit(\"resize\");\n    // Sizing dom elements\n    for (var id in this.elements) {\n      var element = this.elements[id];\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    }\n    // Sizing canvas contexts\n    for (var id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n    }\n    // Sizing WebGL contexts\n    for (var id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n      this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n    }\n    return this;\n  };\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.clear = function () {\n    this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n    return this;\n  };\n  /**\n   * Method used to refresh, i.e. force the renderer to fully reprocess graph\n   * data and render.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.refresh = function () {\n    this.needToProcess = true;\n    this.render();\n    return this;\n  };\n  /**\n   * Method used to schedule a render at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounce refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.scheduleRender = function () {\n    var _this = this;\n    if (!this.renderFrame) {\n      this.renderFrame = (0, utils_1.requestFrame)(function () {\n        _this.render();\n      });\n    }\n    return this;\n  };\n  /**\n   * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n   * at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounce refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.scheduleRefresh = function () {\n    this.needToProcess = true;\n    this.scheduleRender();\n    return this;\n  };\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n  Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n    var _a = this.camera.getState(),\n      ratio = _a.ratio,\n      angle = _a.angle,\n      x = _a.x,\n      y = _a.y;\n    // TODO: handle max zoom\n    var ratioDiff = newRatio / ratio;\n    var center = {\n      x: this.width / 2,\n      y: this.height / 2\n    };\n    var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    var graphCenterPosition = this.viewportToFramedGraph(center);\n    return {\n      angle: angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio\n    };\n  };\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n  Sigma.prototype.viewRectangle = function () {\n    // TODO: reduce relative margin?\n    var marginX = 0 * this.width / 8,\n      marginY = 0 * this.height / 8;\n    var p1 = this.viewportToFramedGraph({\n        x: 0 - marginX,\n        y: 0 - marginY\n      }),\n      p2 = this.viewportToFramedGraph({\n        x: this.width + marginX,\n        y: 0 - marginY\n      }),\n      h = this.viewportToFramedGraph({\n        x: 0,\n        y: this.height + marginY\n      });\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n    var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n    return {\n      x: (1 + viewportPos.x) * this.width / 2,\n      y: (1 - viewportPos.y) * this.height / 2\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n    var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n      x: coordinates.x / this.width * 2 - 1,\n      y: 1 - coordinates.y / this.height * 2\n    });\n    if (isNaN(res.x)) res.x = 0;\n    if (isNaN(res.y)) res.y = 0;\n    return res;\n  };\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  };\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  Sigma.prototype.graphToViewport = function (graphPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  };\n  /**\n   * Method returning the distance multiplier between the graph system and the\n   * viewport system.\n   */\n  Sigma.prototype.getGraphToViewportRatio = function () {\n    var graphP1 = {\n      x: 0,\n      y: 0\n    };\n    var graphP2 = {\n      x: 1,\n      y: 1\n    };\n    var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n    var viewportP1 = this.graphToViewport(graphP1);\n    var viewportP2 = this.graphToViewport(graphP2);\n    var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n    return viewportD / graphD;\n  };\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n  Sigma.prototype.getBBox = function () {\n    return (0, utils_1.graphExtent)(this.graph);\n  };\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n  Sigma.prototype.getCustomBBox = function () {\n    return this.customBBox;\n  };\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.setCustomBBox = function (customBBox) {\n    this.customBBox = customBBox;\n    this.scheduleRender();\n    return this;\n  };\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n  Sigma.prototype.kill = function () {\n    // Emitting \"kill\" events so that plugins and such can cleanup\n    this.emit(\"kill\");\n    // Releasing events\n    this.removeAllListeners();\n    // Releasing camera handlers\n    this.unbindCameraHandlers();\n    // Releasing DOM events & captors\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill();\n    // Releasing graph handlers\n    this.unbindGraphHandlers();\n    // Releasing cache & state\n    this.quadtree = new quadtree_1.default();\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    this.highlightedNodes.clear();\n    // Clearing frames\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n    }\n    if (this.renderHighlightedNodesFrame) {\n      (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    }\n    // Destroying canvases\n    var container = this.container;\n    while (container.firstChild) container.removeChild(container.firstChild);\n  };\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n   * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n   * @return {number}              - The scaled size.\n   */\n  Sigma.prototype.scaleSize = function (size, cameraRatio) {\n    if (size === void 0) {\n      size = 1;\n    }\n    if (cameraRatio === void 0) {\n      cameraRatio = this.camera.ratio;\n    }\n    return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n  };\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n  Sigma.prototype.getCanvases = function () {\n    return __assign({}, this.elements);\n  };\n  return Sigma;\n}(types_1.TypedEventEmitter);\nexports.default = Sigma;","map":{"version":3,"names":["require","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__values","o","Symbol","iterator","m","next","value","done","__importDefault","mod","__esModule","defineProperty","exports","extend_1","camera_1","mouse_1","quadtree_1","types_1","utils_1","labels_1","settings_1","touch_1","matrices_1","edge_collisions_1","X_LABEL_MARGIN","Y_LABEL_MARGIN","applyNodeDefaults","settings","key","data","Error","concat","color","defaultNodeColor","label","undefined","size","hidden","highlighted","forceLabel","type","defaultNodeType","zIndex","applyEdgeDefaults","defaultEdgeColor","defaultEdgeType","Sigma","_super","graph","container","_this","elements","canvasContexts","webGLContexts","activeListeners","quadtree","default","labelGrid","LabelGrid","nodeDataCache","edgeDataCache","nodesWithForcedLabels","edgesWithForcedLabels","nodeExtent","x","y","matrix","identity","invMatrix","correctionRatio","customBBox","normalizationFunction","createNormalizationFunction","graphToViewportRatio","width","height","pixelRatio","getPixelRatio","displayedNodeLabels","Set","displayedEdgeLabels","highlightedNodes","hoveredNode","hoveredEdge","renderFrame","renderHighlightedNodesFrame","needToProcess","checkEdgesEventsFrame","nodePrograms","nodeHoverPrograms","edgePrograms","resolveSettings","validateSettings","validateGraph","HTMLElement","createWebGLContext","preserveDrawingBuffer","createCanvasContext","gl","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","enable","BLEND","nodeProgramClasses","NodeProgramClass","nodes","NodeHoverProgram","nodeHoverProgramClasses","hoverNodes","edgeProgramClasses","EdgeProgramClass","edges","resize","camera","bindCameraHandlers","mouseCaptor","mouse","touchCaptor","bindEventHandlers","bindGraphHandlers","handleSettingsUpdate","refresh","createCanvas","id","canvas","createElement","position","class","appendChild","contextOptions","antialias","getContext","options","context","scheduleRender","on","unbindCameraHandlers","removeListener","mouseIsOnNode","_a","_b","nodeX","nodeY","Math","sqrt","pow","getQuadNodes","mouseGraphPosition","viewportToFramedGraph","point","getNodeAtPosition","quadNodes","minDistance","Infinity","nodeAtPosition","l","node","nodePosition","framedGraphToViewport","scaleSize","distance","handleResize","window","addEventListener","handleMove","e","baseEvent","event","preventSigmaDefault","nodeToHover","emit","scheduleHighlightedNodesRender","pos","enableEdgeHoverEvents","checkEdgeHoverEvents","requestFrame","createMouseListener","eventType","isFakeSigmaMouseEvent","original","enableEdgeWheelEvents","enableEdgeClickEvents","edge","getEdgeAtPoint","handleClick","handleRightClick","handleDoubleClick","handleWheel","handleDown","graphUpdate","scheduleRefresh","dropNodeGraphUpdate","dropEdgeGraphUpdate","clearEdgesGraphUpdate","clearGraphUpdate","unbindGraphHandlers","payload","edgeToHover","e_1","isPixelColored","_c","viewportToGraph","graphX","graphY","transformationRatio","someEdge","_","sourceId","targetId","xs","ys","xt","yt","graphLength","graphToViewport","vp_xs","vp_ys","_d","vp_xt","vp_yt","viewportLength","filterEdges","edgeAttributes","sourcePosition","targetPosition","doEdgeCollideWithPoint","selectedEdge","highestZIndex","edges_1","edges_1_1","getEdgeAttribute","e_1_1","error","return","process","dimensions","getDimensions","nodeZExtent","edgeZExtent","clear","resizeAndClear","labelGridCellSize","graphExtent","nullCamera","nullCameraMatrix","matrixFromCamera","getState","getGraphDimensions","getSetting","nodesPerPrograms","attr","getNodeAttributes","nodeReducer","applyTo","push","reallocate","zIndexOrdering","normalizationRatio","ratio","add","nodeProgram","organize","edgesPerPrograms","getEdgeAttributes","edgeReducer","extremities","sourceData","targetData","minRatio","minCameraRatio","maxRatio","maxCameraRatio","setState","validateState","renderLabels","cameraState","labelsToDisplay","getLabelsToDisplay","labelDensity","labels","has","labelRenderedSizeThreshold","labelRenderer","renderEdgeLabels","edgeLabels","clearRect","edgeLabelsToDisplay","edgeLabelsToDisplayFromNodes","displayedLabels","edgeData","edgeLabelRenderer","renderHighlightedNodes","hovers","render","hoverRenderer","nodesToRender","forEach","COLOR_BUFFER_BIT","program","zoomRatio","sizeRatio","exitRender","cancelFrame","order","moving","isAnimated","isMoving","draggedEvents","currentWheelDirection","viewportDimensions","graphDimensions","padding","getMatrixImpact","getGraphToViewportRatio","params","hideEdgesOnMove","hideLabelsOnMove","getCamera","setCamera","getContainer","getGraph","setGraph","getMouseCaptor","getTouchCaptor","extent","getNodeDisplayData","getEdgeDisplayData","getNodeDisplayedLabels","getEdgeDisplayedLabels","getSettings","setSetting","updateSetting","updater","previousWidth","previousHeight","offsetWidth","offsetHeight","allowInvalidContainer","element","style","setAttribute","scale","viewport","getViewportZoomedState","viewportTarget","newRatio","angle","ratioDiff","center","graphMousePosition","graphCenterPosition","viewRectangle","marginX","marginY","p1","p2","h","x1","y1","x2","y2","coordinates","override","recomputeMatrix","viewportPos","multiplyVec2","res","isNaN","viewportPoint","inverse","graphPoint","graphP1","graphP2","graphD","viewportP1","viewportP2","viewportD","getBBox","getCustomBBox","setCustomBBox","kill","removeAllListeners","removeEventListener","firstChild","removeChild","cameraRatio","zoomToSizeRatioFunction","getCanvases","TypedEventEmitter"],"sources":["/Users/corzanx77/Desktop/Vue代码/corzanX/node_modules/sigma/sigma.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n    if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\"))\n        throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n    if (!data.color)\n        data.color = settings.defaultNodeColor;\n    if (!data.label && data.label !== \"\")\n        data.label = null;\n    if (data.label !== undefined && data.label !== null)\n        data.label = \"\" + data.label;\n    else\n        data.label = null;\n    if (!data.size)\n        data.size = 2;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"highlighted\"))\n        data.highlighted = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultNodeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n    if (!data.color)\n        data.color = settings.defaultEdgeColor;\n    if (!data.label)\n        data.label = \"\";\n    if (!data.size)\n        data.size = 0.5;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultEdgeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */ (function (_super) {\n    __extends(Sigma, _super);\n    function Sigma(graph, container, settings) {\n        if (settings === void 0) { settings = {}; }\n        var _this = _super.call(this) || this;\n        _this.elements = {};\n        _this.canvasContexts = {};\n        _this.webGLContexts = {};\n        _this.activeListeners = {};\n        _this.quadtree = new quadtree_1.default();\n        _this.labelGrid = new labels_1.LabelGrid();\n        _this.nodeDataCache = {};\n        _this.edgeDataCache = {};\n        _this.nodesWithForcedLabels = [];\n        _this.edgesWithForcedLabels = [];\n        _this.nodeExtent = { x: [0, 1], y: [0, 1] };\n        _this.matrix = (0, matrices_1.identity)();\n        _this.invMatrix = (0, matrices_1.identity)();\n        _this.correctionRatio = 1;\n        _this.customBBox = null;\n        _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n            x: [0, 1],\n            y: [0, 1],\n        });\n        // Cache:\n        _this.graphToViewportRatio = 1;\n        // Starting dimensions and pixel ratio\n        _this.width = 0;\n        _this.height = 0;\n        _this.pixelRatio = (0, utils_1.getPixelRatio)();\n        // State\n        _this.displayedNodeLabels = new Set();\n        _this.displayedEdgeLabels = new Set();\n        _this.highlightedNodes = new Set();\n        _this.hoveredNode = null;\n        _this.hoveredEdge = null;\n        _this.renderFrame = null;\n        _this.renderHighlightedNodesFrame = null;\n        _this.needToProcess = false;\n        _this.checkEdgesEventsFrame = null;\n        // Programs\n        _this.nodePrograms = {};\n        _this.nodeHoverPrograms = {};\n        _this.edgePrograms = {};\n        // Resolving settings\n        _this.settings = (0, settings_1.resolveSettings)(settings);\n        // Validating\n        (0, settings_1.validateSettings)(_this.settings);\n        (0, utils_1.validateGraph)(graph);\n        if (!(container instanceof HTMLElement))\n            throw new Error(\"Sigma: container should be an html element.\");\n        // Properties\n        _this.graph = graph;\n        _this.container = container;\n        // Initializing contexts\n        _this.createWebGLContext(\"edges\", { preserveDrawingBuffer: true });\n        _this.createCanvasContext(\"edgeLabels\");\n        _this.createWebGLContext(\"nodes\");\n        _this.createCanvasContext(\"labels\");\n        _this.createCanvasContext(\"hovers\");\n        _this.createWebGLContext(\"hoverNodes\");\n        _this.createCanvasContext(\"mouse\");\n        // Blending\n        for (var key in _this.webGLContexts) {\n            var gl = _this.webGLContexts[key];\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n        // Loading programs\n        for (var type in _this.settings.nodeProgramClasses) {\n            var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n            _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n            var NodeHoverProgram = NodeProgramClass;\n            if (type in _this.settings.nodeHoverProgramClasses) {\n                NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n            }\n            _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, _this);\n        }\n        for (var type in _this.settings.edgeProgramClasses) {\n            var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n            _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n        }\n        // Initial resize\n        _this.resize();\n        // Initializing the camera\n        _this.camera = new camera_1.default();\n        // Binding camera events\n        _this.bindCameraHandlers();\n        // Initializing captors\n        _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n        _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n        // Binding event handlers\n        _this.bindEventHandlers();\n        // Binding graph handlers\n        _this.bindGraphHandlers();\n        // Trigger eventual settings-related things\n        _this.handleSettingsUpdate();\n        // Processing data for the first time & render\n        _this.refresh();\n        return _this;\n    }\n    /**---------------------------------------------------------------------------\n     * Internal methods.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Internal function used to create a canvas element.\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvas = function (id) {\n        var canvas = (0, utils_1.createElement)(\"canvas\", {\n            position: \"absolute\",\n        }, {\n            class: \"sigma-\".concat(id),\n        });\n        this.elements[id] = canvas;\n        this.container.appendChild(canvas);\n        return canvas;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvasContext = function (id) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = {\n            preserveDrawingBuffer: false,\n            antialias: false,\n        };\n        this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n        return this;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n    Sigma.prototype.createWebGLContext = function (id, options) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = __assign({ preserveDrawingBuffer: false, antialias: false }, (options || {}));\n        var context;\n        // First we try webgl2 for an easy performance boost\n        context = canvas.getContext(\"webgl2\", contextOptions);\n        // Else we fall back to webgl\n        if (!context)\n            context = canvas.getContext(\"webgl\", contextOptions);\n        // Edge, I am looking right at you...\n        if (!context)\n            context = canvas.getContext(\"experimental-webgl\", contextOptions);\n        this.webGLContexts[id] = context;\n        return this;\n    };\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindCameraHandlers = function () {\n        var _this = this;\n        this.activeListeners.camera = function () {\n            _this.scheduleRender();\n        };\n        this.camera.on(\"updated\", this.activeListeners.camera);\n        return this;\n    };\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.unbindCameraHandlers = function () {\n        this.camera.removeListener(\"updated\", this.activeListeners.camera);\n        return this;\n    };\n    /**\n     * Method that checks whether or not a node collides with a given position.\n     */\n    Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n        var x = _a.x, y = _a.y;\n        var nodeX = _b.x, nodeY = _b.y;\n        return (x > nodeX - size &&\n            x < nodeX + size &&\n            y > nodeY - size &&\n            y < nodeY + size &&\n            Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size);\n    };\n    /**\n     * Method that returns all nodes in quad at a given position.\n     */\n    Sigma.prototype.getQuadNodes = function (position) {\n        var mouseGraphPosition = this.viewportToFramedGraph(position);\n        return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n    };\n    /**\n     * Method that returns the closest node to a given position.\n     */\n    Sigma.prototype.getNodeAtPosition = function (position) {\n        var x = position.x, y = position.y;\n        var quadNodes = this.getQuadNodes(position);\n        // We will hover the node whose center is closest to mouse\n        var minDistance = Infinity, nodeAtPosition = null;\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n            var node = quadNodes[i];\n            var data = this.nodeDataCache[node];\n            var nodePosition = this.framedGraphToViewport(data);\n            var size = this.scaleSize(data.size);\n            if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n                var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n                // TODO: sort by min size also for cases where center is the same\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nodeAtPosition = node;\n                }\n            }\n        }\n        return nodeAtPosition;\n    };\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindEventHandlers = function () {\n        var _this = this;\n        // Handling window resize\n        this.activeListeners.handleResize = function () {\n            _this.scheduleRender();\n        };\n        window.addEventListener(\"resize\", this.activeListeners.handleResize);\n        // Handling mouse move\n        this.activeListeners.handleMove = function (e) {\n            var baseEvent = {\n                event: e,\n                preventSigmaDefault: function () {\n                    e.preventSigmaDefault();\n                },\n            };\n            var nodeToHover = _this.getNodeAtPosition(e);\n            if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n                // Handling passing from one node to the other directly\n                if (_this.hoveredNode)\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: _this.hoveredNode }));\n                _this.hoveredNode = nodeToHover;\n                _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), { node: nodeToHover }));\n                _this.scheduleHighlightedNodesRender();\n                return;\n            }\n            // Checking if the hovered node is still hovered\n            if (_this.hoveredNode) {\n                var data = _this.nodeDataCache[_this.hoveredNode];\n                var pos = _this.framedGraphToViewport(data);\n                var size = _this.scaleSize(data.size);\n                if (!_this.mouseIsOnNode(e, pos, size)) {\n                    var node = _this.hoveredNode;\n                    _this.hoveredNode = null;\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: node }));\n                    _this.scheduleHighlightedNodesRender();\n                    return;\n                }\n            }\n            if (_this.settings.enableEdgeHoverEvents === true) {\n                _this.checkEdgeHoverEvents(baseEvent);\n            }\n            else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n                if (!_this.checkEdgesEventsFrame)\n                    _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n                        _this.checkEdgeHoverEvents(baseEvent);\n                        _this.checkEdgesEventsFrame = null;\n                    });\n            }\n        };\n        // Handling click\n        var createMouseListener = function (eventType) {\n            return function (e) {\n                var baseEvent = {\n                    event: e,\n                    preventSigmaDefault: function () {\n                        e.preventSigmaDefault();\n                    },\n                };\n                var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n                var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n                if (nodeAtPosition)\n                    return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), { node: nodeAtPosition }));\n                if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n                    var edge = _this.getEdgeAtPoint(e.x, e.y);\n                    if (edge)\n                        return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), { edge: edge }));\n                }\n                return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n            };\n        };\n        this.activeListeners.handleClick = createMouseListener(\"click\");\n        this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n        this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n        this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n        this.activeListeners.handleDown = createMouseListener(\"down\");\n        this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n        this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n        this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n        this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n        this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n        this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n        // TODO\n        // Deal with Touch captor events\n        return this;\n    };\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindGraphHandlers = function () {\n        var _this = this;\n        var graph = this.graph;\n        this.activeListeners.graphUpdate = function () {\n            _this.scheduleRefresh();\n        };\n        this.activeListeners.dropNodeGraphUpdate = function (e) {\n            delete _this.nodeDataCache[e.key];\n            if (_this.hoveredNode === e.key)\n                _this.hoveredNode = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.dropEdgeGraphUpdate = function (e) {\n            delete _this.edgeDataCache[e.key];\n            if (_this.hoveredEdge === e.key)\n                _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearEdgesGraphUpdate = function () {\n            _this.edgeDataCache = {};\n            _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearGraphUpdate = function () {\n            _this.nodeDataCache = {};\n            _this.hoveredNode = null;\n            _this.activeListeners.clearEdgesGraphUpdate();\n        };\n        graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n        graph.on(\"nodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.on(\"edgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n        return this;\n    };\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n    Sigma.prototype.unbindGraphHandlers = function () {\n        var graph = this.graph;\n        graph.removeListener(\"nodeAdded\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n        graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    };\n    /**\n     * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n        var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n        if (edgeToHover !== this.hoveredEdge) {\n            if (this.hoveredEdge)\n                this.emit(\"leaveEdge\", __assign(__assign({}, payload), { edge: this.hoveredEdge }));\n            if (edgeToHover)\n                this.emit(\"enterEdge\", __assign(__assign({}, payload), { edge: edgeToHover }));\n            this.hoveredEdge = edgeToHover;\n        }\n        return this;\n    };\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n    Sigma.prototype.getEdgeAtPoint = function (x, y) {\n        var e_1, _a;\n        var _this = this;\n        var _b = this, edgeDataCache = _b.edgeDataCache, nodeDataCache = _b.nodeDataCache;\n        // Check first that pixel is colored:\n        // Note that mouse positions must be corrected by pixel ratio to correctly\n        // index the drawing buffer.\n        if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio))\n            return null;\n        // Check for each edge if it collides with the point:\n        var _c = this.viewportToGraph({ x: x, y: y }), graphX = _c.x, graphY = _c.y;\n        // To translate edge thicknesses to the graph system, we observe by how much\n        // the length of a non-null edge is transformed to between the graph system\n        // and the viewport system:\n        var transformationRatio = 0;\n        this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n            var xs = _a.x, ys = _a.y;\n            var xt = _b.x, yt = _b.y;\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if (xs !== xt || ys !== yt) {\n                var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n                var _c = _this.graphToViewport({ x: xs, y: ys }), vp_xs = _c.x, vp_ys = _c.y;\n                var _d = _this.graphToViewport({ x: xt, y: yt }), vp_xt = _d.x, vp_yt = _d.y;\n                var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n                transformationRatio = graphLength / viewportLength;\n                return true;\n            }\n        });\n        // If no non-null edge has been found, return null:\n        if (!transformationRatio)\n            return null;\n        // Now we can look for matching edges:\n        var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, \n            // Adapt the edge size to the zoom ratio:\n            _this.scaleSize(edgeDataCache[key].size * transformationRatio))) {\n                return true;\n            }\n        });\n        if (edges.length === 0)\n            return null; // no edges found\n        // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n        var selectedEdge = edges[edges.length - 1];\n        // otherwise select edge with highest zIndex\n        var highestZIndex = -Infinity;\n        try {\n            for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n                var edge = edges_1_1.value;\n                var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n                if (zIndex >= highestZIndex) {\n                    selectedEdge = edge;\n                    highestZIndex = zIndex;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return selectedEdge;\n    };\n    /**\n     * Method used to process the whole graph's data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.process = function () {\n        var _this = this;\n        var graph = this.graph;\n        var settings = this.settings;\n        var dimensions = this.getDimensions();\n        var nodeZExtent = [Infinity, -Infinity];\n        var edgeZExtent = [Infinity, -Infinity];\n        // Clearing the quad\n        this.quadtree.clear();\n        // Resetting the label grid\n        // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n        this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n        // Clear the highlightedNodes\n        this.highlightedNodes = new Set();\n        // Computing extents\n        this.nodeExtent = (0, utils_1.graphExtent)(graph);\n        // Resetting `forceLabel` indices\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        // NOTE: it is important to compute this matrix after computing the node's extent\n        // because #.getGraphDimensions relies on it\n        var nullCamera = new camera_1.default();\n        var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n        // Rescaling function\n        this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n        var nodesPerPrograms = {};\n        var nodes = graph.nodes();\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            // Node display data resolution:\n            //   1. First we get the node's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            //   4. We apply the normalization function\n            // We shallow copy node data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getNodeAttributes(node));\n            if (settings.nodeReducer)\n                attr = settings.nodeReducer(node, attr);\n            var data = applyNodeDefaults(this.settings, node, attr);\n            nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n            this.nodeDataCache[node] = data;\n            this.normalizationFunction.applyTo(data);\n            if (data.forceLabel)\n                this.nodesWithForcedLabels.push(node);\n            if (this.settings.zIndex) {\n                if (data.zIndex < nodeZExtent[0])\n                    nodeZExtent[0] = data.zIndex;\n                if (data.zIndex > nodeZExtent[1])\n                    nodeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.nodePrograms) {\n            if (!this.nodePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n            }\n            this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            nodesPerPrograms[type] = 0;\n        }\n        // Handling node z-index\n        // TODO: z-index needs us to compute display data before hand\n        if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1])\n            nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) { return _this.nodeDataCache[node].zIndex; }, nodes);\n        var normalizationRatio = this.normalizationFunction.ratio;\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            var data = this.nodeDataCache[node];\n            this.quadtree.add(node, data.x, 1 - data.y, this.scaleSize(data.size, 1) / normalizationRatio);\n            if (typeof data.label === \"string\" && !data.hidden)\n                this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n            var nodeProgram = this.nodePrograms[data.type];\n            if (!nodeProgram)\n                throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n            nodeProgram.process(nodesPerPrograms[data.type]++, data);\n            // Save the node in the highlighted set if needed\n            if (data.highlighted && !data.hidden)\n                this.highlightedNodes.add(node);\n        }\n        this.labelGrid.organize();\n        var edgesPerPrograms = {};\n        var edges = graph.edges();\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            // Edge display data resolution:\n            //   1. First we get the edge's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            // We shallow copy edge data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n            if (settings.edgeReducer)\n                attr = settings.edgeReducer(edge, attr);\n            var data = applyEdgeDefaults(this.settings, edge, attr);\n            edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n            this.edgeDataCache[edge] = data;\n            if (data.forceLabel && !data.hidden)\n                this.edgesWithForcedLabels.push(edge);\n            if (this.settings.zIndex) {\n                if (data.zIndex < edgeZExtent[0])\n                    edgeZExtent[0] = data.zIndex;\n                if (data.zIndex > edgeZExtent[1])\n                    edgeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.edgePrograms) {\n            if (!this.edgePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n            }\n            this.edgePrograms[type].reallocate(edgesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            edgesPerPrograms[type] = 0;\n        }\n        // Handling edge z-index\n        if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1])\n            edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) { return _this.edgeDataCache[edge].zIndex; }, edges);\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            var data = this.edgeDataCache[edge];\n            var extremities = graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];\n            this.edgePrograms[data.type].process(edgesPerPrograms[data.type]++, sourceData, targetData, data);\n        }\n        return this;\n    };\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n    Sigma.prototype.handleSettingsUpdate = function () {\n        this.camera.minRatio = this.settings.minCameraRatio;\n        this.camera.maxRatio = this.settings.maxCameraRatio;\n        this.camera.setState(this.camera.validateState(this.camera.getState()));\n        return this;\n    };\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderLabels = function () {\n        if (!this.settings.renderLabels)\n            return this;\n        var cameraState = this.camera.getState();\n        // Selecting labels to draw\n        var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n        (0, extend_1.default)(labelsToDisplay, this.nodesWithForcedLabels);\n        this.displayedNodeLabels = new Set();\n        // Drawing labels\n        var context = this.canvasContexts.labels;\n        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n            var node = labelsToDisplay[i];\n            var data = this.nodeDataCache[node];\n            // If the node was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            // NOTE: we can do better probably\n            if (this.displayedNodeLabels.has(node))\n                continue;\n            // If the node is hidden, we don't need to display its label obviously\n            if (data.hidden)\n                continue;\n            var _a = this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            // NOTE: we can cache the labels we need to render until the camera's ratio changes\n            var size = this.scaleSize(data.size);\n            // Is node big enough?\n            if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold)\n                continue;\n            // Is node actually on screen (with some margin)\n            // NOTE: we used to rely on the quadtree for this, but the coordinates\n            // conversion make it unreliable and at that point we already converted\n            // to viewport coordinates and since the label grid already culls the\n            // number of potential labels to display this looks like a good\n            // performance compromise.\n            // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n            // considering cells obviously outside of the range of the current\n            // view rectangle.\n            if (x < -X_LABEL_MARGIN ||\n                x > this.width + X_LABEL_MARGIN ||\n                y < -Y_LABEL_MARGIN ||\n                y > this.height + Y_LABEL_MARGIN)\n                continue;\n            // Because displayed edge labels depend directly on actually rendered node\n            // labels, we need to only add to this.displayedNodeLabels nodes whose label\n            // is rendered.\n            // This makes this.displayedNodeLabels depend on viewport, which might become\n            // an issue once we start memoizing getLabelsToDisplay.\n            this.displayedNodeLabels.add(node);\n            this.settings.labelRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), this.settings);\n        }\n        return this;\n    };\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderEdgeLabels = function () {\n        if (!this.settings.renderEdgeLabels)\n            return this;\n        var context = this.canvasContexts.edgeLabels;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n            graph: this.graph,\n            hoveredNode: this.hoveredNode,\n            displayedNodeLabels: this.displayedNodeLabels,\n            highlightedNodes: this.highlightedNodes,\n        }).concat(this.edgesWithForcedLabels);\n        var displayedLabels = new Set();\n        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n            var edge = edgeLabelsToDisplay[i], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edge];\n            // If the edge was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            if (displayedLabels.has(edge))\n                continue;\n            // If the edge is hidden we don't need to display its label\n            // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n            if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n                continue;\n            }\n            this.settings.edgeLabelRenderer(context, __assign(__assign({ key: edge }, edgeData), { size: this.scaleSize(edgeData.size) }), __assign(__assign(__assign({ key: extremities[0] }, sourceData), this.framedGraphToViewport(sourceData)), { size: this.scaleSize(sourceData.size) }), __assign(__assign(__assign({ key: extremities[1] }, targetData), this.framedGraphToViewport(targetData)), { size: this.scaleSize(targetData.size) }), this.settings);\n            displayedLabels.add(edge);\n        }\n        this.displayedEdgeLabels = displayedLabels;\n        return this;\n    };\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderHighlightedNodes = function () {\n        var _this = this;\n        var context = this.canvasContexts.hovers;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        // Rendering\n        var render = function (node) {\n            var data = _this.nodeDataCache[node];\n            var _a = _this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            var size = _this.scaleSize(data.size);\n            _this.settings.hoverRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), _this.settings);\n        };\n        var nodesToRender = [];\n        if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n            nodesToRender.push(this.hoveredNode);\n        }\n        this.highlightedNodes.forEach(function (node) {\n            // The hovered node has already been highlighted\n            if (node !== _this.hoveredNode)\n                nodesToRender.push(node);\n        });\n        // Draw labels:\n        nodesToRender.forEach(function (node) { return render(node); });\n        // Draw WebGL nodes on top of the labels:\n        var nodesPerPrograms = {};\n        // 1. Count nodes per type:\n        nodesToRender.forEach(function (node) {\n            var type = _this.nodeDataCache[node].type;\n            nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n        });\n        // 2. Allocate for each type for the proper number of nodes\n        for (var type in this.nodeHoverPrograms) {\n            this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n            // Also reset count, to use when rendering:\n            nodesPerPrograms[type] = 0;\n        }\n        // 3. Process all nodes to render:\n        nodesToRender.forEach(function (node) {\n            var data = _this.nodeDataCache[node];\n            _this.nodeHoverPrograms[data.type].process(nodesPerPrograms[data.type]++, data);\n        });\n        // 4. Clear hovered nodes layer:\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        // 5. Render:\n        for (var type in this.nodeHoverPrograms) {\n            var program = this.nodeHoverPrograms[type];\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                pixelRatio: this.pixelRatio,\n                zoomRatio: this.camera.ratio,\n                sizeRatio: 1 / this.scaleSize(),\n                correctionRatio: this.correctionRatio,\n            });\n        }\n    };\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n    Sigma.prototype.scheduleHighlightedNodesRender = function () {\n        var _this = this;\n        if (this.renderHighlightedNodesFrame || this.renderFrame)\n            return;\n        this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n            // Resetting state\n            _this.renderHighlightedNodesFrame = null;\n            // Rendering\n            _this.renderHighlightedNodes();\n            _this.renderEdgeLabels();\n        });\n    };\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.render = function () {\n        var _this = this;\n        this.emit(\"beforeRender\");\n        var exitRender = function () {\n            _this.emit(\"afterRender\");\n            return _this;\n        };\n        // If a render was scheduled, we cancel it\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n        }\n        // First we need to resize\n        this.resize();\n        // Do we need to reprocess data?\n        if (this.needToProcess)\n            this.process();\n        this.needToProcess = false;\n        // Clearing the canvases\n        this.clear();\n        // If we have no nodes we can stop right there\n        if (!this.graph.order)\n            return exitRender();\n        // TODO: improve this heuristic or move to the captor itself?\n        // TODO: deal with the touch captor here as well\n        var mouseCaptor = this.mouseCaptor;\n        var moving = this.camera.isAnimated() ||\n            mouseCaptor.isMoving ||\n            mouseCaptor.draggedEvents ||\n            mouseCaptor.currentWheelDirection;\n        // Then we need to extract a matrix from the camera\n        var cameraState = this.camera.getState();\n        var viewportDimensions = this.getDimensions();\n        var graphDimensions = this.getGraphDimensions();\n        var padding = this.getSetting(\"stagePadding\") || 0;\n        this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n        this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n        this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n        this.graphToViewportRatio = this.getGraphToViewportRatio();\n        // [jacomyal]\n        // This comment is related to the one above the `getMatrixImpact` definition:\n        // - `this.correctionRatio` is somehow not completely explained\n        // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n        //   graph\n        // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n        // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n        // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n        // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n        var params = {\n            matrix: this.matrix,\n            width: this.width,\n            height: this.height,\n            pixelRatio: this.pixelRatio,\n            zoomRatio: this.camera.ratio,\n            sizeRatio: 1 / this.scaleSize(),\n            correctionRatio: this.correctionRatio,\n        };\n        // Drawing nodes\n        for (var type in this.nodePrograms) {\n            var program = this.nodePrograms[type];\n            program.render(params);\n        }\n        // Drawing edges\n        if (!this.settings.hideEdgesOnMove || !moving) {\n            for (var type in this.edgePrograms) {\n                var program = this.edgePrograms[type];\n                program.render(params);\n            }\n        }\n        // Do not display labels on move per setting\n        if (this.settings.hideLabelsOnMove && moving)\n            return exitRender();\n        this.renderLabels();\n        this.renderEdgeLabels();\n        this.renderHighlightedNodes();\n        return exitRender();\n    };\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n    Sigma.prototype.getCamera = function () {\n        return this.camera;\n    };\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n    Sigma.prototype.setCamera = function (camera) {\n        this.unbindCameraHandlers();\n        this.camera = camera;\n        this.bindCameraHandlers();\n    };\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n    Sigma.prototype.getContainer = function () {\n        return this.container;\n    };\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n    Sigma.prototype.getGraph = function () {\n        return this.graph;\n    };\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n    Sigma.prototype.setGraph = function (graph) {\n        if (graph === this.graph)\n            return;\n        // Unbinding handlers on the current graph\n        this.unbindGraphHandlers();\n        // Clearing the graph data caches\n        this.nodeDataCache = {};\n        this.edgeDataCache = {};\n        // Cleaning renderer state tied to the current graph\n        this.displayedNodeLabels.clear();\n        this.displayedEdgeLabels.clear();\n        this.highlightedNodes.clear();\n        this.hoveredNode = null;\n        this.hoveredEdge = null;\n        this.nodesWithForcedLabels.length = 0;\n        this.edgesWithForcedLabels.length = 0;\n        if (this.checkEdgesEventsFrame !== null) {\n            (0, utils_1.cancelFrame)(this.checkEdgesEventsFrame);\n            this.checkEdgesEventsFrame = null;\n        }\n        // Installing new graph\n        this.graph = graph;\n        // Binding new handlers\n        this.bindGraphHandlers();\n        // Re-rendering now to avoid discrepancies from now to next frame\n        this.refresh();\n    };\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n    Sigma.prototype.getMouseCaptor = function () {\n        return this.mouseCaptor;\n    };\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n    Sigma.prototype.getTouchCaptor = function () {\n        return this.touchCaptor;\n    };\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getDimensions = function () {\n        return { width: this.width, height: this.height };\n    };\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getGraphDimensions = function () {\n        var extent = this.customBBox || this.nodeExtent;\n        return {\n            width: extent.x[1] - extent.x[0] || 1,\n            height: extent.y[1] - extent.y[0] || 1,\n        };\n    };\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n    Sigma.prototype.getNodeDisplayData = function (key) {\n        var node = this.nodeDataCache[key];\n        return node ? Object.assign({}, node) : undefined;\n    };\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's usefull for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n    Sigma.prototype.getEdgeDisplayData = function (key) {\n        var edge = this.edgeDataCache[key];\n        return edge ? Object.assign({}, edge) : undefined;\n    };\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n    Sigma.prototype.getNodeDisplayedLabels = function () {\n        return new Set(this.displayedNodeLabels);\n    };\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n    Sigma.prototype.getEdgeDisplayedLabels = function () {\n        return new Set(this.displayedEdgeLabels);\n    };\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n    Sigma.prototype.getSettings = function () {\n        return __assign({}, this.settings);\n    };\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n    Sigma.prototype.getSetting = function (key) {\n        return this.settings[key];\n    };\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n    Sigma.prototype.setSetting = function (key, value) {\n        this.settings[key] = value;\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n    Sigma.prototype.updateSetting = function (key, updater) {\n        this.settings[key] = updater(this.settings[key]);\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.resize = function () {\n        var previousWidth = this.width, previousHeight = this.height;\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n        this.pixelRatio = (0, utils_1.getPixelRatio)();\n        if (this.width === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.width = 1;\n            else\n                throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n        }\n        if (this.height === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.height = 1;\n            else\n                throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n        }\n        // If nothing has changed, we can stop right here\n        if (previousWidth === this.width && previousHeight === this.height)\n            return this;\n        this.emit(\"resize\");\n        // Sizing dom elements\n        for (var id in this.elements) {\n            var element = this.elements[id];\n            element.style.width = this.width + \"px\";\n            element.style.height = this.height + \"px\";\n        }\n        // Sizing canvas contexts\n        for (var id in this.canvasContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            if (this.pixelRatio !== 1)\n                this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n        }\n        // Sizing WebGL contexts\n        for (var id in this.webGLContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n        }\n        return this;\n    };\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.clear = function () {\n        this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n        this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n        return this;\n    };\n    /**\n     * Method used to refresh, i.e. force the renderer to fully reprocess graph\n     * data and render.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.refresh = function () {\n        this.needToProcess = true;\n        this.render();\n        return this;\n    };\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounce refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.scheduleRender = function () {\n        var _this = this;\n        if (!this.renderFrame) {\n            this.renderFrame = (0, utils_1.requestFrame)(function () {\n                _this.render();\n            });\n        }\n        return this;\n    };\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounce refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.scheduleRefresh = function () {\n        this.needToProcess = true;\n        this.scheduleRender();\n        return this;\n    };\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n    Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n        var _a = this.camera.getState(), ratio = _a.ratio, angle = _a.angle, x = _a.x, y = _a.y;\n        // TODO: handle max zoom\n        var ratioDiff = newRatio / ratio;\n        var center = {\n            x: this.width / 2,\n            y: this.height / 2,\n        };\n        var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n        var graphCenterPosition = this.viewportToFramedGraph(center);\n        return {\n            angle: angle,\n            x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n            y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n            ratio: newRatio,\n        };\n    };\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n    Sigma.prototype.viewRectangle = function () {\n        // TODO: reduce relative margin?\n        var marginX = (0 * this.width) / 8, marginY = (0 * this.height) / 8;\n        var p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }), p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }), h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });\n        return {\n            x1: p1.x,\n            y1: p1.y,\n            x2: p2.x,\n            y2: p2.y,\n            height: p2.y - h.y,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n        var matrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0)\n                : this.matrix;\n        var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n        return {\n            x: ((1 + viewportPos.x) * this.width) / 2,\n            y: ((1 - viewportPos.y) * this.height) / 2,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n        var invMatrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true)\n                : this.invMatrix;\n        var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n            x: (coordinates.x / this.width) * 2 - 1,\n            y: 1 - (coordinates.y / this.height) * 2,\n        });\n        if (isNaN(res.x))\n            res.x = 0;\n        if (isNaN(res.y))\n            res.y = 0;\n        return res;\n    };\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    };\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.graphToViewport = function (graphPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    };\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n    Sigma.prototype.getGraphToViewportRatio = function () {\n        var graphP1 = { x: 0, y: 0 };\n        var graphP2 = { x: 1, y: 1 };\n        var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n        var viewportP1 = this.graphToViewport(graphP1);\n        var viewportP2 = this.graphToViewport(graphP2);\n        var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n        return viewportD / graphD;\n    };\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n    Sigma.prototype.getBBox = function () {\n        return (0, utils_1.graphExtent)(this.graph);\n    };\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n    Sigma.prototype.getCustomBBox = function () {\n        return this.customBBox;\n    };\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.setCustomBBox = function (customBBox) {\n        this.customBBox = customBBox;\n        this.scheduleRender();\n        return this;\n    };\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n    Sigma.prototype.kill = function () {\n        // Emitting \"kill\" events so that plugins and such can cleanup\n        this.emit(\"kill\");\n        // Releasing events\n        this.removeAllListeners();\n        // Releasing camera handlers\n        this.unbindCameraHandlers();\n        // Releasing DOM events & captors\n        window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n        this.mouseCaptor.kill();\n        this.touchCaptor.kill();\n        // Releasing graph handlers\n        this.unbindGraphHandlers();\n        // Releasing cache & state\n        this.quadtree = new quadtree_1.default();\n        this.nodeDataCache = {};\n        this.edgeDataCache = {};\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        this.highlightedNodes.clear();\n        // Clearing frames\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n        }\n        if (this.renderHighlightedNodesFrame) {\n            (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n            this.renderHighlightedNodesFrame = null;\n        }\n        // Destroying canvases\n        var container = this.container;\n        while (container.firstChild)\n            container.removeChild(container.firstChild);\n    };\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n    Sigma.prototype.scaleSize = function (size, cameraRatio) {\n        if (size === void 0) { size = 1; }\n        if (cameraRatio === void 0) { cameraRatio = this.camera.ratio; }\n        return ((size / this.settings.zoomToSizeRatioFunction(cameraRatio)) *\n            (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1));\n    };\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n    Sigma.prototype.getCanvases = function () {\n        return __assign({}, this.elements);\n    };\n    return Sigma;\n}(types_1.TypedEventEmitter));\nexports.default = Sigma;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}