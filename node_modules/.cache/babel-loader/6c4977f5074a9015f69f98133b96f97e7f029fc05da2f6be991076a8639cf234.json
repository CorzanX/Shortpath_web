{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Vue from 'vue';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar KEYCODE_ENTER = 13;\nvar KEYCODE_TAB = 9;\nvar KEYCODE_BACKSPACE = 8;\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar KEYCODE_ESCAPE = 27;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = typeof window !== 'undefined' && navigator && /*#__PURE__*/ /Win/i.test(navigator.platform);\nvar isMacLike = typeof window !== 'undefined' && navigator && /*#__PURE__*/ /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar PrismEditor = /*#__PURE__*/Vue.extend({\n  props: {\n    lineNumbers: {\n      type: Boolean,\n      \"default\": false\n    },\n    autoStyleLineNumbers: {\n      type: Boolean,\n      \"default\": true\n    },\n    readonly: {\n      type: Boolean,\n      \"default\": false\n    },\n    value: {\n      type: String,\n      \"default\": ''\n    },\n    highlight: {\n      type: Function,\n      required: true\n    },\n    tabSize: {\n      type: Number,\n      \"default\": 2\n    },\n    insertSpaces: {\n      type: Boolean,\n      \"default\": true\n    },\n    ignoreTabKey: {\n      type: Boolean,\n      \"default\": false\n    },\n    placeholder: {\n      type: String,\n      \"default\": ''\n    }\n  },\n  data: function data() {\n    return {\n      capture: true,\n      history: {\n        stack: [],\n        offset: -1\n      },\n      lineNumbersHeight: '20px',\n      codeData: ''\n    };\n  },\n  watch: {\n    value: {\n      immediate: true,\n      handler: function handler(newVal) {\n        if (!newVal) {\n          this.codeData = '';\n        } else {\n          this.codeData = newVal;\n        }\n      }\n    },\n    content: {\n      immediate: true,\n      handler: function handler() {\n        var _this = this;\n        if (this.lineNumbers) {\n          this.$nextTick(function () {\n            _this.setLineNumbersHeight();\n          });\n        }\n      }\n    },\n    lineNumbers: function lineNumbers() {\n      var _this2 = this;\n      this.$nextTick(function () {\n        _this2.styleLineNumbers();\n        _this2.setLineNumbersHeight();\n      });\n    }\n  },\n  computed: {\n    isEmpty: function isEmpty() {\n      return this.codeData.length === 0;\n    },\n    content: function content() {\n      var result = this.highlight(this.codeData) + '<br />'; // todo: VNode support?\n\n      return result;\n    },\n    lineNumbersCount: function lineNumbersCount() {\n      var totalLines = this.codeData.split(/\\r\\n|\\n/).length;\n      return totalLines;\n    }\n  },\n  mounted: function mounted() {\n    this._recordCurrentState();\n    this.styleLineNumbers();\n  },\n  methods: {\n    setLineNumbersHeight: function setLineNumbersHeight() {\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre).height;\n    },\n    styleLineNumbers: function styleLineNumbers() {\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\n      var $editor = this.$refs.pre;\n      var $lineNumbers = this.$el.querySelector('.prism-editor__line-numbers');\n      var editorStyles = window.getComputedStyle($editor);\n      this.$nextTick(function () {\n        var btlr = 'border-top-left-radius';\n        var bblr = 'border-bottom-left-radius';\n        if (!$lineNumbers) return;\n        $lineNumbers.style[btlr] = editorStyles[btlr];\n        $lineNumbers.style[bblr] = editorStyles[bblr];\n        $editor.style[btlr] = '0';\n        $editor.style[bblr] = '0';\n        var stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\n        stylesList.forEach(function (style) {\n          $lineNumbers.style[style] = editorStyles[style];\n        });\n        $lineNumbers.style['margin-bottom'] = '-' + editorStyles['padding-top'];\n      });\n    },\n    _recordCurrentState: function _recordCurrentState() {\n      var input = this.$refs.textarea;\n      if (!input) return; // Save current state of the input\n\n      var value = input.value,\n        selectionStart = input.selectionStart,\n        selectionEnd = input.selectionEnd;\n      this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      });\n    },\n    _getLines: function _getLines(text, position) {\n      return text.substring(0, position).split('\\n');\n    },\n    _applyEdits: function _applyEdits(record) {\n      // Save last selection state\n      var input = this.$refs.textarea;\n      var last = this.history.stack[this.history.offset];\n      if (last && input) {\n        this.history.stack[this.history.offset] = _extends({}, last, {\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd\n        });\n      } // Save the changes\n\n      this._recordChange(record);\n      this._updateInput(record);\n    },\n    _recordChange: function _recordChange(record, overwrite) {\n      if (overwrite === void 0) {\n        overwrite = false;\n      }\n      var _this$history = this.history,\n        stack = _this$history.stack,\n        offset = _this$history.offset;\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        this.history.stack = stack.slice(0, offset + 1); // Limit the number of operations to 100\n\n        var count = this.history.stack.length;\n        if (count > HISTORY_LIMIT) {\n          var extras = count - HISTORY_LIMIT;\n          this.history.stack = stack.slice(extras, count);\n          this.history.offset = Math.max(this.history.offset - extras, 0);\n        }\n      }\n      var timestamp = Date.now();\n      if (overwrite) {\n        var last = this.history.stack[this.history.offset];\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          var _this$_getLines$pop, _this$_getLines$pop2;\n\n          // A previous entry exists and was in short interval\n          // Match the last word in the line\n          var re = /[^a-z0-9]([a-z0-9]+)$/i; // Get the previous line\n\n          var previous = (_this$_getLines$pop = this._getLines(last.value, last.selectionStart).pop()) === null || _this$_getLines$pop === void 0 ? void 0 : _this$_getLines$pop.match(re); // Get the current line\n\n          var current = (_this$_getLines$pop2 = this._getLines(record.value, record.selectionStart).pop()) === null || _this$_getLines$pop2 === void 0 ? void 0 : _this$_getLines$pop2.match(re);\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            this.history.stack[this.history.offset] = _extends({}, record, {\n              timestamp: timestamp\n            });\n            return;\n          }\n        }\n      } // Add the new operation to the stack\n\n      this.history.stack.push(_extends({}, record, {\n        timestamp: timestamp\n      }));\n      this.history.offset++;\n    },\n    _updateInput: function _updateInput(record) {\n      var input = this.$refs.textarea;\n      if (!input) return; // Update values and selection state\n\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n      this.$emit('input', record.value); // this.props.onValueChange(record.value);\n    },\n\n    handleChange: function handleChange(e) {\n      var _e$target = e.target,\n        value = _e$target.value,\n        selectionStart = _e$target.selectionStart,\n        selectionEnd = _e$target.selectionEnd;\n      this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      }, true);\n      this.$emit('input', value); // this.props.onValueChange(value);\n    },\n\n    _undoEdit: function _undoEdit() {\n      var _this$history2 = this.history,\n        stack = _this$history2.stack,\n        offset = _this$history2.offset; // Get the previous edit\n\n      var record = stack[offset - 1];\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.max(offset - 1, 0);\n      }\n    },\n    _redoEdit: function _redoEdit() {\n      var _this$history3 = this.history,\n        stack = _this$history3.stack,\n        offset = _this$history3.offset; // Get the next edit\n\n      var record = stack[offset + 1];\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    },\n    handleKeyDown: function handleKeyDown(e) {\n      // console.log(navigator.platform);\n      var tabSize = this.tabSize,\n        insertSpaces = this.insertSpaces,\n        ignoreTabKey = this.ignoreTabKey;\n      if (this.$listeners.keydown) {\n        // onKeyDown(e);\n        this.$emit('keydown', e);\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        e.target.blur();\n        this.$emit('blur', e);\n      }\n      var _e$target2 = e.target,\n        value = _e$target2.value,\n        selectionStart = _e$target2.selectionStart,\n        selectionEnd = _e$target2.selectionEnd;\n      var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\n        // Prevent focus change\n        e.preventDefault();\n        if (e.shiftKey) {\n          // Unindent selected lines\n          var linesBeforeCaret = this._getLines(value, selectionStart);\n          var startLine = linesBeforeCaret.length - 1;\n          var endLine = this._getLines(value, selectionEnd).length - 1;\n          var nextValue = value.split('\\n').map(function (line, i) {\n            if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n              return line.substring(tabCharacter.length);\n            }\n            return line;\n          }).join('\\n');\n          if (value !== nextValue) {\n            var startLineText = linesBeforeCaret[startLine];\n            this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length)\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          var _linesBeforeCaret = this._getLines(value, selectionStart);\n          var _startLine = _linesBeforeCaret.length - 1;\n          var _endLine = this._getLines(value, selectionEnd).length - 1;\n          var _startLineText = _linesBeforeCaret[_startLine];\n          this._applyEdits({\n            value: value.split('\\n').map(function (line, i) {\n              if (i >= _startLine && i <= _endLine) {\n                return tabCharacter + line;\n              }\n              return line;\n            }).join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(_startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (_endLine - _startLine + 1)\n          });\n        } else {\n          var updatedSelection = selectionStart + tabCharacter.length;\n          this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        var hasSelection = selectionStart !== selectionEnd;\n        var textBeforeCaret = value.substring(0, selectionStart);\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n          var _updatedSelection = selectionStart - tabCharacter.length;\n          this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: _updatedSelection,\n            selectionEnd: _updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          var line = this._getLines(value, selectionStart).pop();\n          var matches = line === null || line === void 0 ? void 0 : line.match(/^\\s+/);\n          if (matches && matches[0]) {\n            e.preventDefault(); // Preserve indentation on inserting a new line\n\n            var indent = '\\n' + matches[0];\n            var _updatedSelection2 = selectionStart + indent.length;\n            this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: _updatedSelection2,\n              selectionEnd: _updatedSelection2\n            });\n          }\n        }\n      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n        var chars;\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        } // console.log(isMacLike, \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform));\n        // If text is selected, wrap them in the characters\n\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n          this._applyEdits({\n            value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd + 2\n          });\n        }\n      } else if ((isMacLike ?\n      // Trigger undo with ⌘+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z :\n      // Trigger undo with Ctrl+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n        e.preventDefault();\n        this._undoEdit();\n      } else if ((isMacLike ?\n      // Trigger redo with ⌘+Shift+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ?\n      // Trigger redo with Ctrl+Y on Windows\n      e.ctrlKey && e.keyCode === KEYCODE_Y :\n      // Trigger redo with Ctrl+Shift+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n        e.preventDefault();\n        this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault(); // Toggle capturing tab key so users can focus away\n\n        this.capture = !this.capture;\n      }\n    }\n  },\n  render: function render(h) {\n    var _this3 = this;\n    var lineNumberWidthCalculator = h('div', {\n      attrs: {\n        \"class\": 'prism-editor__line-width-calc',\n        style: 'height: 0px; visibility: hidden; pointer-events: none;'\n      }\n    }, '999');\n    var lineNumbers = h('div', {\n      staticClass: 'prism-editor__line-numbers',\n      style: {\n        'min-height': this.lineNumbersHeight\n      },\n      attrs: {\n        'aria-hidden': 'true'\n      }\n    }, [lineNumberWidthCalculator, Array.from(Array(this.lineNumbersCount).keys()).map(function (_, index) {\n      return h('div', {\n        attrs: {\n          \"class\": 'prism-editor__line-number token comment'\n        }\n      }, \"\" + ++index);\n    })]);\n    var textarea = h('textarea', {\n      ref: 'textarea',\n      on: {\n        input: this.handleChange,\n        keydown: this.handleKeyDown,\n        click: function click($event) {\n          _this3.$emit('click', $event);\n        },\n        keyup: function keyup($event) {\n          _this3.$emit('keyup', $event);\n        },\n        focus: function focus($event) {\n          _this3.$emit('focus', $event);\n        },\n        blur: function blur($event) {\n          _this3.$emit('blur', $event);\n        }\n      },\n      staticClass: 'prism-editor__textarea',\n      \"class\": {\n        'prism-editor__textarea--empty': this.isEmpty\n      },\n      attrs: {\n        spellCheck: 'false',\n        autocapitalize: 'off',\n        autocomplete: 'off',\n        autocorrect: 'off',\n        'data-gramm': 'false',\n        placeholder: this.placeholder,\n        'data-testid': 'textarea',\n        readonly: this.readonly\n      },\n      domProps: {\n        value: this.codeData\n      }\n    });\n    var preview = h('pre', {\n      ref: 'pre',\n      staticClass: 'prism-editor__editor',\n      attrs: {\n        'data-testid': 'preview'\n      },\n      domProps: {\n        innerHTML: this.content\n      }\n    });\n    var editorContainer = h('div', {\n      staticClass: 'prism-editor__container'\n    }, [textarea, preview]);\n    return h('div', {\n      staticClass: 'prism-editor-wrapper'\n    }, [this.lineNumbers && lineNumbers, editorContainer]);\n  }\n});\nexport { PrismEditor };","map":{"version":3,"names":["KEYCODE_ENTER","KEYCODE_TAB","KEYCODE_BACKSPACE","KEYCODE_Y","KEYCODE_Z","KEYCODE_M","KEYCODE_PARENS","KEYCODE_BRACKETS","KEYCODE_QUOTE","KEYCODE_BACK_QUOTE","KEYCODE_ESCAPE","HISTORY_LIMIT","HISTORY_TIME_GAP","isWindows","window","navigator","test","platform","isMacLike","PrismEditor","Vue","extend","props","lineNumbers","type","Boolean","autoStyleLineNumbers","readonly","value","String","highlight","Function","required","tabSize","Number","insertSpaces","ignoreTabKey","placeholder","data","capture","history","stack","offset","lineNumbersHeight","codeData","watch","immediate","handler","newVal","content","$nextTick","_this","setLineNumbersHeight","_this2","styleLineNumbers","computed","isEmpty","length","result","lineNumbersCount","totalLines","split","mounted","_recordCurrentState","methods","getComputedStyle","$refs","pre","height","$editor","$lineNumbers","$el","querySelector","editorStyles","btlr","bblr","style","stylesList","forEach","input","textarea","selectionStart","selectionEnd","_recordChange","_getLines","text","position","substring","_applyEdits","record","last","_extends","_updateInput","overwrite","_this$history","slice","count","extras","Math","max","timestamp","Date","now","_this$_getLines$pop","_this$_getLines$pop2","re","previous","pop","match","current","startsWith","push","$emit","handleChange","e","target","_e$target","_undoEdit","_this$history2","_redoEdit","_this$history3","min","handleKeyDown","$listeners","keydown","defaultPrevented","keyCode","blur","_e$target2","tabCharacter","repeat","preventDefault","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","line","i","join","startLineText","_linesBeforeCaret","_startLine","_endLine","_startLineText","updatedSelection","hasSelection","textBeforeCaret","endsWith","_updatedSelection","matches","indent","_updatedSelection2","chars","metaKey","ctrlKey","altKey","render","h","lineNumberWidthCalculator","attrs","staticClass","Array","from","keys","_","index","ref","on","click","$event","_this3","keyup","focus","spellCheck","autocapitalize","autocomplete","autocorrect","domProps","preview","innerHTML","editorContainer"],"sources":["../src/Editor.ts"],"sourcesContent":["import Vue, { VNode } from 'vue';\n\nimport './styles.css';\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = typeof window !== 'undefined' && navigator && /Win/i.test(navigator.platform);\nconst isMacLike = typeof window !== 'undefined' && navigator && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nexport interface EditorProps {\n  lineNumbers: boolean;\n  autoStyleLineNumbers: boolean;\n  readonly: boolean;\n  value: string;\n  highlight: () => string;\n  tabSize: number;\n  insertSpaces: boolean;\n  ignoreTabKey: boolean;\n  placeholder: string;\n}\nexport interface Record {\n  value: string;\n  selectionStart: number;\n  selectionEnd: number;\n}\n\nexport interface History {\n  stack: Array<Record & { timestamp: number }>;\n  offset: number;\n}\n\nexport const PrismEditor = Vue.extend({\n  props: {\n    lineNumbers: {\n      type: Boolean,\n      default: false,\n    },\n    autoStyleLineNumbers: {\n      type: Boolean,\n      default: true,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    value: {\n      type: String,\n      default: '',\n    },\n    highlight: {\n      type: Function,\n      required: true,\n    },\n    tabSize: {\n      type: Number,\n      default: 2,\n    },\n    insertSpaces: {\n      type: Boolean,\n      default: true,\n    },\n    ignoreTabKey: {\n      type: Boolean,\n      default: false,\n    },\n    placeholder: {\n      type: String,\n      default: '',\n    },\n  },\n  data() {\n    return {\n      capture: true,\n      history: {\n        stack: [],\n        offset: -1,\n      } as History,\n      lineNumbersHeight: '20px',\n      codeData: '',\n    };\n  },\n  watch: {\n    value: {\n      immediate: true,\n      handler(newVal: string): void {\n        if (!newVal) {\n          this.codeData = '';\n        } else {\n          this.codeData = newVal;\n        }\n      },\n    },\n    content: {\n      immediate: true,\n      handler(): void {\n        if (this.lineNumbers) {\n          this.$nextTick(() => {\n            this.setLineNumbersHeight();\n          });\n        }\n      },\n    },\n    lineNumbers(): void {\n      this.$nextTick(() => {\n        this.styleLineNumbers();\n        this.setLineNumbersHeight();\n      });\n    },\n  },\n  computed: {\n    isEmpty(): boolean {\n      return this.codeData.length === 0;\n    },\n    content(): string {\n      const result = this.highlight(this.codeData) + '<br />';\n      // todo: VNode support?\n      return result;\n    },\n    lineNumbersCount(): number {\n      const totalLines = this.codeData.split(/\\r\\n|\\n/).length;\n      return totalLines;\n    },\n  },\n  mounted() {\n    this._recordCurrentState();\n    this.styleLineNumbers();\n  },\n\n  methods: {\n    setLineNumbersHeight(): void {\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre as HTMLTextAreaElement).height;\n    },\n    styleLineNumbers(): void {\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\n\n      const $editor = this.$refs.pre as HTMLTextAreaElement;\n      const $lineNumbers: HTMLDivElement | null = this.$el.querySelector('.prism-editor__line-numbers');\n      const editorStyles = window.getComputedStyle($editor);\n\n      this.$nextTick(() => {\n        const btlr: any = 'border-top-left-radius';\n        const bblr: any = 'border-bottom-left-radius';\n        if (!$lineNumbers) return;\n        $lineNumbers.style[btlr] = editorStyles[btlr];\n        $lineNumbers.style[bblr] = editorStyles[bblr];\n        $editor.style[btlr] = '0';\n        $editor.style[bblr] = '0';\n\n        const stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\n        stylesList.forEach((style: any) => {\n          $lineNumbers.style[style] = editorStyles[style];\n        });\n        $lineNumbers.style['margin-bottom' as any] = '-' + editorStyles['padding-top' as any];\n      });\n    },\n    _recordCurrentState(): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n      // Save current state of the input\n      const { value, selectionStart, selectionEnd } = input;\n\n      this._recordChange({\n        value,\n        selectionStart,\n        selectionEnd,\n      });\n    },\n    _getLines(text: string, position: number): Array<string> {\n      return text.substring(0, position).split('\\n');\n    },\n    _applyEdits(record: Record): void {\n      // Save last selection state\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n      const last = this.history.stack[this.history.offset];\n\n      if (last && input) {\n        this.history.stack[this.history.offset] = {\n          ...last,\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd,\n        };\n      }\n\n      // Save the changes\n      this._recordChange(record);\n      this._updateInput(record);\n    },\n    _recordChange(record: Record, overwrite = false): void {\n      const { stack, offset } = this.history;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        this.history.stack = stack.slice(0, offset + 1);\n\n        // Limit the number of operations to 100\n        const count = this.history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          const extras = count - HISTORY_LIMIT;\n\n          this.history.stack = stack.slice(extras, count);\n          this.history.offset = Math.max(this.history.offset - extras, 0);\n        }\n      }\n\n      const timestamp = Date.now();\n\n      if (overwrite) {\n        const last = this.history.stack[this.history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n\n          // Match the last word in the line\n          const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n          // Get the previous line\n          const previous = this._getLines(last.value, last.selectionStart).pop()?.match(re);\n\n          // Get the current line\n          const current = this._getLines(record.value, record.selectionStart).pop()?.match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            this.history.stack[this.history.offset] = {\n              ...record,\n              timestamp,\n            };\n\n            return;\n          }\n        }\n      }\n\n      // Add the new operation to the stack\n      this.history.stack.push({ ...record, timestamp });\n      this.history.offset++;\n    },\n\n    _updateInput(record: Record): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n\n      // Update values and selection state\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      this.$emit('input', record.value);\n      // this.props.onValueChange(record.value);\n    },\n    handleChange(e: KeyboardEvent): void {\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      this._recordChange(\n        {\n          value,\n          selectionStart,\n          selectionEnd,\n        },\n        true\n      );\n      this.$emit('input', value);\n      // this.props.onValueChange(value);\n    },\n    _undoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the previous edit\n      const record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.max(offset - 1, 0);\n      }\n    },\n    _redoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the next edit\n      const record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    },\n    handleKeyDown(e: KeyboardEvent): void {\n      // console.log(navigator.platform);\n      const { tabSize, insertSpaces, ignoreTabKey } = this;\n\n      if (this.$listeners.keydown) {\n        // onKeyDown(e);\n        this.$emit('keydown', e);\n\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        (<HTMLTextAreaElement>e.target).blur();\n        this.$emit('blur', e);\n      }\n\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const nextValue = value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n                return line.substring(tabCharacter.length);\n              }\n\n              return line;\n            })\n            .join('\\n');\n\n          if (value !== nextValue) {\n            const startLineText = linesBeforeCaret[startLine];\n\n            this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter)\n                ? selectionStart - tabCharacter.length\n                : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length),\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: value\n              .split('\\n')\n              .map((line, i) => {\n                if (i >= startLine && i <= endLine) {\n                  return tabCharacter + line;\n                }\n\n                return line;\n              })\n              .join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n          });\n        } else {\n          const updatedSelection = selectionStart + tabCharacter.length;\n\n          this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        const hasSelection = selectionStart !== selectionEnd;\n        const textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          const updatedSelection = selectionStart - tabCharacter.length;\n\n          this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          const line = this._getLines(value, selectionStart).pop();\n          const matches = line?.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault();\n\n            // Preserve indentation on inserting a new line\n            const indent = '\\n' + matches[0];\n            const updatedSelection = selectionStart + indent.length;\n\n            this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: updatedSelection,\n              selectionEnd: updatedSelection,\n            });\n          }\n        }\n      } else if (\n        e.keyCode === KEYCODE_PARENS ||\n        e.keyCode === KEYCODE_BRACKETS ||\n        e.keyCode === KEYCODE_QUOTE ||\n        e.keyCode === KEYCODE_BACK_QUOTE\n      ) {\n        let chars;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        }\n\n        // console.log(isMacLike, \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform));\n\n        // If text is selected, wrap them in the characters\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          this._applyEdits({\n            value:\n              value.substring(0, selectionStart) +\n              chars[0] +\n              value.substring(selectionStart, selectionEnd) +\n              chars[1] +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart,\n            selectionEnd: selectionEnd + 2,\n          });\n        }\n      } else if (\n        (isMacLike\n          ? // Trigger undo with ⌘+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z\n          : // Trigger undo with Ctrl+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n        !e.shiftKey &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._undoEdit();\n      } else if (\n        (isMacLike\n          ? // Trigger redo with ⌘+Shift+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n          : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault();\n\n        // Toggle capturing tab key so users can focus away\n        this.capture = !this.capture;\n      }\n    },\n  },\n  render(h): VNode {\n    const lineNumberWidthCalculator = h(\n      'div',\n      {\n        attrs: {\n          class: 'prism-editor__line-width-calc',\n          style: 'height: 0px; visibility: hidden; pointer-events: none;',\n        },\n      },\n      '999'\n    );\n    const lineNumbers = h(\n      'div',\n      {\n        staticClass: 'prism-editor__line-numbers',\n        style: {\n          'min-height': this.lineNumbersHeight,\n        },\n        attrs: {\n          'aria-hidden': 'true',\n        },\n      },\n      [\n        lineNumberWidthCalculator,\n        Array.from(Array(this.lineNumbersCount).keys()).map((_, index) => {\n          return h('div', { attrs: { class: 'prism-editor__line-number token comment' } }, `${++index}`);\n        }),\n      ]\n    );\n\n    const textarea = h('textarea', {\n      ref: 'textarea',\n      on: {\n        input: this.handleChange,\n        keydown: this.handleKeyDown,\n        click: ($event: MouseEvent) => {\n          this.$emit('click', $event);\n        },\n        keyup: ($event: KeyboardEvent) => {\n          this.$emit('keyup', $event);\n        },\n        focus: ($event: FocusEvent) => {\n          this.$emit('focus', $event);\n        },\n        blur: ($event: FocusEvent) => {\n          this.$emit('blur', $event);\n        },\n      },\n      staticClass: 'prism-editor__textarea',\n      class: {\n        'prism-editor__textarea--empty': this.isEmpty,\n      },\n      attrs: {\n        spellCheck: 'false',\n        autocapitalize: 'off',\n        autocomplete: 'off',\n        autocorrect: 'off',\n        'data-gramm': 'false',\n        placeholder: this.placeholder,\n        'data-testid': 'textarea',\n        readonly: this.readonly,\n      },\n      domProps: {\n        value: this.codeData,\n      },\n    });\n    const preview = h('pre', {\n      ref: 'pre',\n      staticClass: 'prism-editor__editor',\n      attrs: {\n        'data-testid': 'preview',\n      },\n      domProps: {\n        innerHTML: this.content,\n      },\n    });\n    const editorContainer = h('div', { staticClass: 'prism-editor__container' }, [textarea, preview]);\n    return h('div', { staticClass: 'prism-editor-wrapper' }, [this.lineNumbers && lineNumbers, editorContainer]);\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}